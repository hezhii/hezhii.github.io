<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CA 证书]]></title>
    <url>%2F2017%2F11%2Fcertification%2F</url>
    <content type="text"><![CDATA[CA 证书是由 CA 机构颁发的一个文件，文件中包含了公钥和公钥持有者的信息，它就像是一张身份证，可以用来核对证书持有者的身份信息。 证书内容CA 证书是经由 CA 机构进行数字签名过的，包含公钥、公钥拥有者（即申请者）信息、签发者信息、有效期等信息的文件。在 Mac 电脑上的 钥匙串访问 中可以看到电脑中的证书信息，证书部分内容如下图所示。 从图中我们可以看到，证书中包含了很多的信息，目前数字证书的格式遵循 X.509 标准。 验证证书在 HTTPS 通信中，服务器将非对称加密的公钥放置在证书中，然后将证书发送给客户端，客户端收到证书后验证证书，如果验证通过就可以确认公钥来自于服务器。那么，客户端如何验证证书呢？证书又是如何防伪的呢？ 证书的验证和防伪需要用到证书中提供了两个信息：签发者使用的签名算法、指纹（签名），其中签名算法是证书签发机构对证书进行签名时所采用的算法。当客户端收到服务器发送过来的证书后，先对证书中的内容（证书内容是明文）进行检查，例如：证书是否在过期、公钥所有者 url 与当前服务器域名是否对应等。接着，为了防止其他人仿造证书（例如：将证书中的公钥和 url 替换成自己的），还需要验证证书的指纹。通过证书中提供的签名算法，生成证书内容的信息摘要，根据摘要算法的特性，如果证书内容被修改了，那么生成的摘要信息肯定就不一样。但是，如果其他人在替换证书内容后，根据新的内容重新生成信息摘要该怎么办呢？ 因此，不能只是将证书内容的信息摘要作为指纹，而是使用 CA 机构的私钥对信息摘要进行加密，将加密后的内容作为指纹。客户端在验证时，使用 CA 机构提供的公钥解密指纹，然后将解密后的信息摘要与自己根据证书内容生成的信息摘要进行对比，如果两者相同，则说明证书没有被篡改。这样的话，如果其他人修改了证书内容并重新生成了信息摘要，由于没有 CA 机构的私钥，根本无法生成可以被 CA 机构的公钥解密出来的指纹，就能有效地防止证书被篡改。那么问题来了，如何确保 CA 的公钥是真实可信的呢？显然通过网络传输是无法确保的。事实上，在操作系统（或浏览器）中已经内置了世界上公认可信的 CA 证书，该证书中包含了公钥。这样的机构不会很多，所以完全可以做到内置。 信任链所谓信任链就是说：A 信任 B，而 B 信任 C，所以 A 也信任 C。事实上，系统中并没有内置世界上所有 CA 机构的证书，只是内置了顶级 CA 机构的证书，而其他机构则通过信任链的方式进行证书的颁发。假设 A 是顶级 CA，系统中内置该机构的证书。B 是 A 的子机构，A 给 B 颁发了 CA 证书，B 给 C 颁发了 CA 证书，客户端验证 C 的证书的过程如下： 按照上文提到了证书验证方式，检查 C 的证书。 由于 C 的证书是由 B 颁发的，因此需要先获取 B 的证书，然后使用 B 的证书中的公钥解密指纹并对比信息摘要。 为了保证 B 的公钥真实可靠，需要验证 B 的证书，而 B 的证书是由 A 颁发的，所以使用 A 的公钥解密指纹并对比信息摘要。 A 的公钥内置在系统中，认为是真实有效地。 通过这种信任链的机制，就能完成对证书的认证。可见，这里的关键之处在于顶级 CA 证书，这类证书通常系统内置，世界公认可信。所以，不要自己手贱乱添加证书啊~~~]]></content>
      <categories>
        <category>技术</category>
        <category>Web 通信</category>
      </categories>
      <tags>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我理解的 HTTPS]]></title>
    <url>%2F2017%2F11%2Fhttps%2F</url>
    <content type="text"><![CDATA[HTTPS 是 HTTP 的安全版，在 HTTP 下增加了 SSL 层，对传输的数据进行了加密，使得通信更加的安全。但是，因为 HTTPS 需要建立更多的通信，并且数据在传输的过程中需要进行加密、解密，所以网站访问速度要比 HTTP 慢。 以前我对于 HTTPS 的了解仅限于此，知其然不知其所以然。前段时间在工作中需要部署 HTTPS，趁着这次机会更加全面的了解了 HTTPS，现通过这篇博客谈谈我对于 HTTPS 的一点理解。 加密算法HTTPS 协议下传输的数据都进行了加密，因此在了解 HTTPS 之前需要先了解一下加密算法。 加密算法有很多，主要可以分为对称加密算法、非对称加密算法。对称加密通过加密算法和密钥对原始数据进行加密得到密文，如果想要获得原始数据，则需要使用加密时使用的密钥及算法的逆算法对密文进行解密，在对称加密算法只使用一个密钥，如：DES 算法；非对称机密与对称加密不同之处在于，非对称加密过程中需要使用两个密钥，这两个密钥被称为公钥和私钥，公钥加密后的数据只能使用私钥解密，而私钥加密后的数据只能使用公钥解密，较之对称加密具有更高的安全性，如：RSA 算法。 除了对称加密和非对称加密之外，还有一类加密算法叫做 Hash 算法。 哈希算法将任意长度的二进制值映射为较短的固定长度的二进制值，这个小的二进制值称为哈希值。哈希值是一段数据唯一且极其紧凑的数值表示形式。如果散列一段明文而且哪怕只更改该段落的一个字母，随后的哈希都将产生不同的值。要找到散列为同一个值的两个不同的输入，在计算上是不可能的，所以数据的哈希值可以检验数据的完整性。一般用于快速查找和加密算法。 百度百科哈希算法 Hash 算法 是不可逆算法，不可逆指无法（并不是完全没有办法，只是难度很高）根据密文得到原始数据。同时，即使原始数据发生一点变化，通过 Hash 算法得到的 Hash 值也将不同，因此 Hash 算法通常用来生成信息摘要或签名，如：MD5 算法。 HTTPS 的原理我们都知道 HTTP 协议是明文传递数据的，这就导致了在数据传递的过程中如果被第三方截获，那么通信内容对于第三方就是完全透明的。因此，如果要保证通信的安全，最先想到的就是对传输的数据进行加密，这样即使被第三方截获，他也无法得知通信的原始内容。 根据上文提到的加密算法，如果要加密数据，可以使用对称加密或者非对称加密。对称加密和非对称加密的区别在于，对称加密中加密和解密使用的是相同的密钥，而非对称加密中使用的是公钥和私钥，因此 非对称加密要比对称加密更加安全，不过在执行效率上，对称加密比非对称加密的效率要高得多，尤其是在数据较大时，如果使用非对称加密会很慢。因此，对于数据的加密，应该使用对称加密。但是，使用对称加密时却存在一个问题，那就是 通信双方无法安全的进行密钥交换，因为在密钥的传输过程中，有可能密钥会被第三方所截获，一旦密钥被截获，那么传输的密文就可以被第三方解密出来，丧失安全性。因此对称加密的密钥不能通过明文传输，必须也要经过加密。 那么应该如何加密对称加密时使用的密钥呢？如果仍然使用对称加密，那么就进入到了一个死循环状态，此时，就轮到非对称加密登场了。非对称加密解决了对称加密中的密钥传输问题，它使用了两个密钥，其中公钥通常用来分发，而私钥则自己保留。在建立安全通信时，由通信的一方（以下称为“甲方”）生成公钥和私钥，然后将公钥传输给另一方（以下称为“乙方”），其中公钥采用明文传输的方式。乙方在收到甲方传递过来的公钥后，生成对称加密的密钥，然后用公钥进行加密并将加密后的密文返回给甲方。甲方在收到包含对称加密密钥的密文后，使用自己保留的私钥进行解密即可获得密钥。此后，双方就能使用对称加密的密钥进行安全的通信了。 在上述过程中，即使包含对称加密密钥的密文被第三方截获，第三方因为没有私钥，所以无法解密密文获取对称加密的密钥。这一过程看似没有问题，实则不然。在甲方传递公钥给乙方的过程中，如果第三方截获了公钥，并自己生成了新的公钥和私钥，然后把自己的公钥传递给乙方，乙方在收到第三方的公钥后（乙方不知情，他以为公钥是甲方给他的），生成对称加密的密钥，然后用公钥加密，并返回给甲方，这一过程又被第三方所截获，因为公钥是自己的，所以第三方可以用自己的私钥解密并获取对称加密的密钥。接着，第三方用之前截获的甲方的公钥，对对称加密的密钥进行加密并返回给甲方，因为公钥是甲方的，所以甲方可以成功用自己的私钥解密并获得密钥。这样，在甲乙双方不知情的情况下，第三方已经成功的获取到了双方通信时所使用的密钥了，如下图所示。那么问题来了，乙方在收到公钥后，如何确保这个公钥是甲方给他的呢？ 这个问题就好比是有一天一个人跑过来和你说他是马云，他出来玩没带钱，如果你给他 100 块钱打车回家，他回去后给你 1 个亿。遇到这种情况，你如何能知道他就是马云呢？身份证拿出来看看！这基本是脱口而出的回答。那么要解决上述问题，甲方在发送公钥给乙方时，就还需要把自己的身份证给乙方看看。那甲方这个身份证如何来的呢？如何能确保身份证是不是真的呢？从现实生活中，我们可以得出答案。人民币由中国银行发行，所有人都承认人民币是有效地，并且人民币有特殊的制造工艺，具备防伪标识。 至此，显然只通过甲乙双方是无法建立安全通信的，需要一个第三方的权威机构介入，这个权威机构被称为 CA（Certificate Authority），在甲方申请后，CA 机构给甲方颁发“身份证”，甲方在发送公钥时连同自己的“身份证”一起发送给乙方，乙方通过核实“身份证”来确认公钥是否来自甲方。那么乙方如何核实“身份证”，并且如何确保“身份证”不会被伪造呢？这就需要一种只有 CA 能产出，并且所有乙方都能识别的机制，而非对称加密正好就满足这种一对多的机制。CA 机构通过自己的私钥对“身份证”进行加密生成密文，其中“身份证”被称为 数字证书，而密文则被称为 数字签名，然后将签名附加到证书中（签在底部），最后将经过签名后的证书颁发给甲方。于是，甲方在发送公钥时，连同证书一起发送给乙方，乙方在收到后，使用 CA 机构的公钥解密签名，对比签名的内容和证书内容是否相同即可验证甲方身份。那么问题又来了，乙方如何知道 CA 机构的公钥呢？显然如果继续通过网络传输的方式获取，这个问题可能永远都无法解决，而考虑到这样的权威机构可能只需要一个就够了，完全可以让乙方一开始就保留着该公钥，例如：浏览器内置 CA 机构的公钥。通过这样的机制，甲乙两方就能建立安全的通信了。具体关于 CA 证书的介绍以及它是如何证明公钥没有被篡改的，见我另外一篇博客。 HTTPS 通信过程前面在了解了 HTTPS 的原理之后，再来说说 HTTPS 的具体通信过程，HTTPS 通信的过程基本就是原理中提到的几个步骤，具体如下： 客户端向服务端 Say Hello，包含支持的 SSL 协议版本、加密算法、密钥长度等信息。 服务端响应客户端信息发送 Server Hello 报文，报文中包含确定的加密算法、密钥长度等信息。 服务端发送证书给客户端。 最后服务器发送 Server Hello Done 报文通知客户端，最初阶段的SSL握手协商部分结束。 客户端收到证书后，验证证书的有效性。如果证书无效，在浏览器上会提示；如果验证有效，发送 Client Key Exchange 报文给服务端，报文中包含被称为 Pre-master secret 的随机码，该随机码通过服务端证书中的公钥进行加密。 接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，在此报文之后的通信会使用 Pre-master secret 密钥加密。 客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。如果服务器能解密出来，则握手成功。 服务端收到 Finished 报文并成功解密后，同样发送 Change Cipher Spec 报文和 Finished 报文给客户端。 成功建立安全连接，进行 HTTP 通信，底层通过 SSL 加密。 通信结束，发送报文关闭连接。]]></content>
      <categories>
        <category>技术</category>
        <category>Web 通信</category>
      </categories>
      <tags>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 gulp-istanbul 无法解析 async/await 的问题]]></title>
    <url>%2F2017%2F11%2Fgulp-istanbul-es6%2F</url>
    <content type="text"><![CDATA[最近，在使用 Gulp 执行 Mocha 单元测试并生成测试覆盖率报告时执行一直出错，出错的原因是因为代码解析时出现不能识别的代码。这篇博客记录了问题的原因及我最后选择的处理办法。 现象我使用 gulp-mocha 和 gulp-istanbul 插件执行单元测试并生成代码覆盖率报告，对应 gulpfile.js 中的内容如下： 123456789101112131415const istanbul = require('gulp-istanbul');const mocha = require('gulp-mocha');gulp.task('pre-test', function () &#123; return gulp.src(['src/**/*.js']) .pipe(istanbul()) .pipe(istanbul.hookRequire());&#125;);gulp.task('test', ['pre-test'], function () &#123; return gulp.src(['test/unit/**/*.test.js']) .pipe(mocha()) .pipe(istanbul.writeReports()) .pipe(istanbul.enforceThresholds(&#123; thresholds: &#123; global: 90 &#125; &#125;));&#125;); 上面的内容是 gulp-istanbul 插件文档中的示例用法，然而在执行时却出错了，主要的错误信息如下图所示。 从上图中可以看出，出错的原因是出现了无法解析的字符，在查看了对应了代码后发现无法解析的是 async/await。 原因在发现 gulp-istanbul 无法解析 async/await 之后，我通过 Google 查找了相关资料，最后在 istanbul 的一个 issue 中找到了问题的原因所在：gulp-istanbul 依赖了 istanbul，而最新版本的 istanbul 无法解析 async/await，需要将 istanbul 升级到下一个版本，详情戳这里。 我通过 npm i -D istanbul@next 命令将 istanbul 升级到下一个版本，然后单独的生成代码覆盖率报告，发现确实可以成功解析 async/await。然而，gulp-istanbul 插件依赖的是 istanbul 最新发布的稳定版本，该版本并不能解析 async/await。 于此同时，我在 gulp-istanbul 的 issue 中也发现了有人提出了同样的问题。作者在 issue 中指出了稳定版的 istanbul 不支持 ES6，需要提供一个插装器。但是，我按照文档的示例添加插装器后，仍然无法解决该问题。该 issue 的提出者也表示了该方法并不能起作用，并希望 gulp-istanbul 的作者更新依赖的 istanbul 到下一个版本，然而作者表示没有时间去支持一个不稳定的版本，很乐意接受 PR。😂 😂 😂 到这里，我意识到目前想要直接通过 gulp-istanbul 插件生成代码覆盖率有点困难。 解决办法我注意到 istanbul 已经升级到了 2.0 版本并且由一个新的团队负责开发，名称也改成了 nyc。它支持 await/nyc，但是很遗憾，我并没有找到相应的 gulp 插件，所以最终我打算在 task 中简单地执行 Node 脚本命令来执行 Mocha 并生成代码覆盖率报告。 根据 Gulp API 文档可知，gulp.task(name[, deps], fn) 方法就是定义了一个任务及任务对应的动作，执行某个任务就是执行对应的方法。同时，该方法支持异步操作并提供了多种方法： 接受一个 callback 参数，当 task 结束时调用该方法即可，类似于 Mocha 中的 done()。 返回一个 stream，stream 可以被 pipe() 到其他插件中。 返回一个 promise。 因此，我只用提供一个方法，在该方法中运行 mocha 和 nyc，然后对运行的结果进行一个包装即可，详情戳这里。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Gulp</tag>
        <tag>Istanbul</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gulp 初体验]]></title>
    <url>%2F2017%2F11%2Fglup%2F</url>
    <content type="text"><![CDATA[Gulp.js 是一个自动化构建工具，开发者可以使用它在项目开发过程中自动执行常见任务。Gulp.js 是基于 Node.js 构建的，利用 Node.js 流的威力，你可以快速构建项目并减少频繁的 IO 操作。Gulp.js 源文件和你用来定义任务的 Gulp 文件都是通过 JavaScript（或者 CoffeeScript ）源码来实现的。 安装全局安装1$ npm i -g gulp 项目依赖1$ npm i -D gulp 开始使用在项目的根目录下创建 gulpfile.js 文件，然后通过 API 以及各类插件定义所需的自动化任务。 Gulp 的 API 十分简单，只有四个，分别是： gulp.src: 载入资源 gulp.dest: 输出数据 gulp.task: 定义任务 gulp.watch: 监视文件修改 在定义好了自动化构建的任务之后，执行 gulp 将会运行默认的名为 default 的任务。如果想要运行特定的任务，在命令后面添加相应任务的名称即可，gulp &lt;task&gt; &lt;othertask&gt;。 定义自动化任务下面记录我在一个 Node.js 项目中初次使用 Gulp 的经历，通过 Gulp 我主要想完成代码审查、执行单元测试、测试覆盖率检查、打包这一自动化构建流程。 ESlint首先安装 ESlint 插件。 1$ npm i -D gulp-eslint 然后将文档中介绍的用法直接复制到 gulpfile.js 中，此时 gulpfile.js 的内容如下： 12345678910111213const gulp = require('gulp');const eslint = require('gulp-eslint');gulp.task('lint', () =&gt; &#123; return gulp.src(['**/*.js', '!node_modules/**']) .pipe(eslint()) .pipe(eslint.format()) .pipe(eslint.failAfterError());&#125;);gulp.task('default', ['lint'], function () &#123; // This will only run if the lint task is successful...&#125;); 定义好了 lint 任务后，直接运行 gulp 命令，控制台输出如下： 为了测试是否真的起作用，我故意添加一个审查错误的代码，出错时输出如下： Mocha首先安装 Mocha 插件。 1$ npm i -D gulp-mocha 定义如下任务，并添加到默认任务中。 1234567891011121314151617gulp.task('test', function () &#123; process.env.NODE_ENV = 'test'; return gulp.src('test/unit/**/*.test.js') .pipe(mocha(&#123; reporter: 'nyan', timeout: 5000, globals: &#123; should: require('should') &#125; &#125;)) .once('error', () =&gt; &#123; process.exit(1); &#125;) .once('end', () =&gt; &#123; process.exit(); &#125;);&#125;); Mocha 具体支持哪些参数见官网文档，这里需要注意的是在测试执行完成后手动的调用 process.exit() 结束进程，否则会处于阻塞状态。参考 gulp-mocha 文档中的描述。 同时，在一开始的时候我的测试用例无法通过，最后发现是因为 NODE_ENV 没有指定导致，这里需要注意设置 NODE_ENV。 代码覆盖率在这一部分遇到了一些问题，问题的主要原因是因为我在代码中使用了 async/await，关于这个问题的详细说明请点这里。此处，只列出最终解决后 gulpfile 中的内容，如下： 123456789101112131415/** * 执行单元测试并生成代码覆盖率报告 */gulp.task('test', () =&gt; _exec('npm test'));/** * 代码覆盖率 */gulp.task('coverage', ['test'], () =&gt; _exec('npm run coverage'));function _exec (command, args = [], options = &#123;shell: true, stdio: 'inherit'&#125;) &#123; return new Promise((resolve, reject) =&gt; spawn(normalize(command), args, options) .on('close', code =&gt; code ? reject(new Error(`$&#123;command&#125;: $&#123;code&#125;`)) : resolve()) );&#125; 从上面的代码可以看到，在执行测试以及代码覆盖率检查时我并没有使用 gulp 插件，而是执行了相应的脚本，package.json 中对应的脚本如下： 123456"scripts": &#123; "dev": "NODE_ENV=development DEBUG=host2.0:* node index.js", "lint": "eslint ./ || exit 0", "test": "NODE_ENV=test nyc --reporter=html --reporter=text mocha -R nyan --recursive ./test/unit", "coverage": "nyc check-coverage --lines 90 --functions 100 --branches 100" &#125;, 打包代码审查及测试通过后需要打包便于发布，打包代码使用的是 gulp-zip 插件，首先安装插件： 1$ npm i -D gulp-zip 然后再 gulpfile 中添加下面内容： 123456789101112131415/** * 打包 */gulp.task('pack', ['coverage'], () =&gt; gulp.src(['src/**', 'index.js', 'package.json', 'package-lock.json', 'README.md', '.nvmrc'], &#123;base: '.'&#125;) .pipe(zip('archive-' + getVersion() + '.zip')) .pipe(gulp.dest('./')));/** * 获取版本号 */function getVersion () &#123; return JSON.parse(fs.readFileSync('./package.json', 'utf8')).version;&#125; 这里有个需要注意的地方，一是获取版本号时直接读取的 json 文件而不是使用 require，这是因为 require 会缓存多次调用，这会导致版本号不会被更新掉；二是在使用 gulp-zip 打包时，如果希望打包后的文件在解压后依旧保留顶级目录，需要在调用 gulp.src 载入资源时，添加 base 参数，参看 issue。 总结Gulp 初次体验下来感觉很合我的胃口，目前只是简单地使用并没有太多深入的研究，主要是在用法上感觉很舒服。定义一个个的任务，然后通过任务的各种组合来完成不同的自动化流程，我感觉看着比 Grunt 要清晰，不过可能是因为我看到 Grunt 的配置功能更复杂的原因导致的。在今后，会尝试使用 Gulp 来完成更加复杂的构建工作，我相信它会给我带来更多的惊喜。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js 单元测试]]></title>
    <url>%2F2017%2F10%2Fnodejs-unit%2F</url>
    <content type="text"><![CDATA[以前写 Java 程序的时候会使用 JUnit 写一些单元测试，一方面测试代码是否存在 bug，另一方面在日后修改代码后重新跑一边测试用例，如果能全部通过也可以改得放心。现在接手了一些 Node.js 的开发工作，单元测试同样也是必不可少的。 用到的库目前在进行 Node.js 单元测试的工作中，主要用到了下面的一些技术： Mocha：Mocha (我喜欢叫”抹茶”）是一个功能十分丰富的 JavaScript 测试框架，在浏览器和 Node.js 环境中都可以运行。 Chai：Chai 是一个断言库，它提供了大量的断言帮助我们更加轻松的测试代码。 Sinon：Sinon.js 是一个测试工具，它提供了 spy，stub，mock 等功能帮助我们监测函数的运行情况或者轻松地创建一个函数替代品等。 Should：BDD 风格的断言库。 Istanbul：Istanbul 是一个统计代码覆盖率的工具。 这里就不对以上框架或库进行详细的说明了，在它们的官网上有详细的介绍和文档。 基本使用我们可以在 Mocha 官访文档上看到详细的使用说明，一个 Mocha 结合 Chai 编写的测试差不多长这样： 1234567891011121314151617181920212223242526272829303132333435describe('数据库操作测试', function() &#123; describe('同步数据库表', function() &#123; it('应该返回一个对象', function(done) &#123; // 异步 callback 写法 models.sequelize.sync().then(function(result) &#123; // expect 风格断言，结果需要被 expect() 包裹起来 expect(result).to.be.an('object'); done(); &#125;); &#125;); &#125;); describe('添加主机信息', function() &#123; it('返回一个 model 实例', function() &#123; // 异步 Promise 写法 return models.Info.create(&#123; ID: 'unit_test', NAME: 'unit_test' &#125;).then(function(model) &#123; expect(model).to.be.an('object'); expect(model.get('ID')).to.equal('unit_test'); &#125;); &#125;); it('数据库表中应该有该条数据', function() &#123; return models.Info.findOne(&#123; where: &#123; ID: 'unit_test', &#125; &#125;).then(function(model) &#123; expect(model.get('NAME')).to.equal('unit_test'); &#125;); &#125;); &#125;);&#125;); 其中 describe 定义了一类测试，相当于是一个分组，可以互相嵌套；it 则是一个测试单元，在里面编写具体的测试代码。测试代码就是执行正式代码并将执行后的结果与期望的结果进行比较，如果都相同那么测试通过，如果有一个不同则测试不通过。 断言库使用的 Chai ，它支持多种风格的断言，主要是 expect 和 should，我理解的区别主要有下面几点： expect 风格只需要引入 expect 方法，而 should 需要引入 should()，方法需要执行。 在写法上，should 比 expect 更加简单，expect(result).to.equal(1) 等同于 result.should.equal(1)。 expect 将结果进行了一个包装，可以在所有浏览器和 Node.js 上运行；should 扩展了原型对象，提供了一个 getter 作为断言的入口，不支持 IE。 Sinon目前主要用到了 Sinon 提供的 spy 和 stub 方法，这两个方法可以使我们更加轻松地达成测试条件。例如：我们要测试一个需要删除数据库中的一条数据的方法，而我们并不想真的删除数据库中的内容，即使是测试库。这时就轮到 stub 上场了。 stub可以为数据库操作提供一个替身，在测试的过程中原本进行数据库操作的方法并不会被调用，而是调用了替身方法并记录下来调用信息。我们甚至可以让替身方法返回不同的值，以满足不同的需求。spy 的功能与 stub类似，它也会记录方法的调用信息，但是原本的方法仍会被执行。Sinon 的用法如下： 12345678910111213141516171819202122232425262728293031const should = require('should');const sinon = require('sinon');const cacheControl = require('../../../src/middleware/cache-control');const sandbox = sinon.sandbox.create();describe('测试中间件: cacheControl', function() &#123; let res; beforeEach(function() &#123; res = &#123; set: sandbox.spy() &#125;; &#125;); afterEach(function() &#123; sandbox.restore(); &#125;); it('正确设置 HTTP header', function(done) &#123; cacheControl('private')(null, res, function(args) &#123; should.not.exist(args); res.set.calledOnce.should.be.true(); res.set.calledWith(&#123; 'Cache-Control': 'no-cache, private, no-store, must-revalidate, max-stale=0, post-check=0, pre-check=0' &#125;).should.be.true(); done(); &#125;); &#125;);&#125;); 说明： 我这里使用了另一个断言库 should。 无论是 spy 还是 stub，如果不执行 restore 方法，那么他们的统计结果将会不断累积。 通过 sandbox 我们可以集中地进行 restore。同时，在 mocha 提供的钩子方法中进行更加爽歪歪。 引入代码覆盖率检测执行 npm install istanbul --save-dev 安装 Istanbul，安装完成中在命令行中输入相应的命令即可。 使用 istanbul cover [file] 命令即可以得到相应文件的覆盖率，同时这条命令还会生成一个 coverage 目录（默认是项目根目录，可以通过参数配置），目录下的 coverage.json 文件包含覆盖率的原始数据，而打开 lcov-report/index.html 文件则可以通过浏览器页面看到更加直观地覆盖率报告。 得到覆盖率后，可以通过 istanbul check-coverage 命令设置期望达到的覆盖率，同时检查当前代码是否达标。例如： 12$ istanbul check-coverage --statement 90 # 语句覆盖率应达到 90%$ istanbul check-coverage --statement -80 --branch -90 --function 100 # 80% 语句覆盖率、90% 分支覆盖率和 100% 的函数覆盖率 在 WebStorm 中使用在 WebStorm 中通过简单地几下配置，我们就可以更加方便的使用 Mocha 进行单元测试。 首先，在工具栏上选择 Run-&gt;Edit Configurations 或者下图中的入口进行到 Run/Debug 的配置页面。 配置页面如下图所示，通过顶部的 + 按钮我们可以新建 Run/Debug 项，这里我们选择运行环境为 Mocha。 在启动项的配置中，我们配置好名称、Node.js 目录、Mocha 包目录、测试文件路径即可运行测试，注意勾选测试路径下面的 include subdirectories 选项，这样才会递归的测试执行子目录中的单元测试文件。 配置完成后，我们点击窗口顶部的 Run 或者 Debug 按钮即可执行测试用例，执行的结果会显示在标签页内显示，如下图所示。 此时，在编辑区左侧显示行数的地方会出现一些小按钮，点击按钮可以单独的执行相应的测试单元，如下图所示。 这里需要注意的是，单独的执行测试单元相当于会新建一个 Run/Debug 项，如果在执行单元测试的过程中我们需要指定一些参数，在 Edit Configurations 页面的 Mocha 默认配置中配置运行参数即可。这样，执行测试单元时也会应用该配置。]]></content>
      <categories>
        <category>技术</category>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Istanbul</tag>
        <tag>Mocha</tag>
        <tag>Chai</tag>
        <tag>Sinon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sequelize 基本用法]]></title>
    <url>%2F2017%2F10%2Fsequelize-usage%2F</url>
    <content type="text"><![CDATA[最近在工作中开始写 Node.js 应用，数据库使用的 PostgreSQL，为了方便数据库操作打算使用一款 ORM 框架。在 GitHub 上找到了 node-orm2 和 sequelize 两款，最终因为 star 数和更加全面的文档选择了 sequelize。现通过这篇博客记录下 sequelize 的一些基本用法。 简单介绍 Sequelize is a promise-based ORM for Node.js v4 and up. It supports the dialects PostgreSQL, MySQL, SQLite and MSSQL and features solid transaction support, relations, read replication and more. Seqeulize 是 Node.js 上的一个 ORM 框架。根据官网上的介绍，她支持多种数据库、支持写原生 SQL、事务、关联关系、读复制等功能。 Sequelize 使用简单，有十分详细的官方文档，在 GitHub上也有一个 express-example 说明在 Express 中的基本使用方法。她基于 Promise，因此可以很方便的进行异步处理。 基本用法Sequelize 的用法在官网上有很详细的介绍，这里只记录下比较常用的几点基本用法。 安装直接通过 NPM 或者 Yarn 安装即可，需要同时安装相应数据库连接的驱动。 1234567891011121314151617// Using NPM$ npm install --save sequelize# And one of the following:$ npm install --save pg pg-hstore$ npm install --save mysql2$ npm install --save sqlite3$ npm install --save tedious // MSSQL// Using Yarn$ yarn add sequelize# And one of the following:$ yarn add pg pg-hstore$ yarn add mysql2$ yarn add sqlite3$ yarn add tedious // MSSQL 建立连接建立连接就是初始化一个 Sequelize 对象。在初始化 Sequelize 实例时会创建一个数据库连接池，所以在单线程模式下最好一个数据库下新建一个实例；如果是多线程模式则需要在创建多个实例，并且设置每一个连接池的最大连接数为总的最大连接数除以线程个数。 Sequelize 支持多个初始化参数，同时支持多种写法： 1234567891011121314151617// without password and optionsconst sequelize = new Sequelize('database', 'username')// without optionsconst sequelize = new Sequelize('database', 'username', 'password')// without password / with blank passwordconst sequelize = new Sequelize('database', 'username', null, &#123;&#125;)// with password and optionsconst sequelize = new Sequelize('my_database', 'john', 'doe', &#123;&#125;)// with database, username, and password in the options objectconst sequelize = new Sequelize(&#123; database, username, password &#125;);// with uriconst sequelize = new Sequelize('mysql://localhost:3306/database', &#123;&#125;) 我习惯通过一个对象传入所有的参数，这样直接从配置文件中读取并传入即可，不需要过多的操作。例如： 12345678910111213const sequelize = new Sequelize(&#123; host: 'localhost', database: 'test', port: 3432, dialect: 'postgres', // 连接的数据库类型，mysql, postgres, sqlite and mssql username: 'test', password: 'test', pool: &#123; // 连接池配置 max: 5, min: 0, idle: 10000 &#125;&#125;); 定义模型在初始化 Sequelize 对象的实例后，通过调用实例对象的 define 方法可以定义模型，例如： 12345678910111213141516171819sequelize.define('modelName', &#123; columnA: &#123; type: Sequelize.BOOLEAN, validate: &#123; is: ["[a-z]",'i'], // will only allow letters max: 23, // only allow values &lt;= 23 isIn: &#123; args: [['en', 'zh']], msg: "Must be English or Chinese" &#125; &#125;, field: 'column_a' // Other attributes here &#125;, columnB: Sequelize.STRING, columnC: 'MY VERY OWN COLUMN TYPE'&#125;)sequelize.models.modelName; // The model will now be available in models under the name given to define define 方法支持三个参数，分别是：模型名称、属性、可选参数，具体可以查阅官方文档。同时，Sequelize 还提供了一个 import 方法，支持从一个文件中导入模型，具体的写法可以参考官网提供的 Demo。 每一个模型对应一张数据库表，初始化模型时的每一个属性对应一个表中的一个字段。其中，字段是一个对象，可以指定字段类型、是否为主键、是否唯一、校验等。 定义完模型后，即可通过 Sequelize 对象实例的 sync 方法同步模型到数据库表中。默认情况下当模型对应的数据表不存在时，会创建对应的数据库表，可以通过 force 参数控制。这里需要注意的是：在创建数据库表时，Sequelize 会使用 &#39;modelName&#39; + &#39;s&#39; 作为表名称，如果想使用 modelName 作为表名，在定义模型时设置 freezeTableName 参数为 true 即可。 CURD在定义模型并同步模型到数据库表后，通过模型的静态方法和实例方法，可以很方便的进行数据库操作。下面主要介绍最为常见的增删改查方法。 添加数据添加数据主要有两种方法，一种是先创建一个模型实例，然后调用实例的 save 方法；另一种则是直接通过模型的静态 create 方法。例如： 123456789101112131415161718192021222324// 方法1：先创建实例，然后调用实例的 save 方法const user = User.build(&#123; 'emp_id': '1', 'nick': '小红', 'department': '技术部'&#125;);user.save().then(function() &#123; // success&#125;).catch(function(err) &#123; // error&#125;);// 方法2：通过静态 create 方法const user = User.create(&#123; 'emp_id': '2', 'nick': '小明', 'department': '技术部'&#125;).then(function() &#123; // success&#125;).catch(function(err) &#123; // error&#125;); 删除数据直接调用模型的静态方法 destroy 即可，通过 options.where 可以指定查询参数。例如： 123456789User.destroy(&#123; where: &#123; emp_id: '1', &#125;&#125;).then(function(count) &#123; // success&#125;).catch(function(err) &#123; // error&#125;); 修改数据修改数据可以直接调用静态的 update 方法，也可以通过查询方法获取到数据对应的实例对象，然后直接修改对象的属性，最后调用 save 方法写入到数据库中。例如： 12345678// 方法1：操作对象属性（不会操作db），调用save后操作dbuser.nick = '小白';user = yield user.save();// 方法2：直接update操作dbuser = yield user.update(&#123; 'nick': '小白白'&#125;); 查询数据查询数据主要通过模型的静态方法，模型提供了多个 API 以满足查询需求。例如： 123456789101112131415161718192021User.findAndCount(&#123; where: &#123; sex: '女' &#125;, order: [ ['emp_id', 'age'] ], limit: 10, offset: 0&#125;).then(function(result) &#123; // success const data = []; const total = result.count; result.rows.forEach(function(item) &#123; data.push(item.toJSON()); &#125;); logger.debug('查询完成，耗时 %d ms，查询到 %d 条结果。结果为： %s', Date.now() - startTime, total, JSON.stringify(data));&#125;).catch(function(err) &#123; // error&#125;); 事务在 Seqeulize 中使用事务主要通过对象实例的 transaction 方法。该方法会创建一个 Transaction 对象实例，接着在执行数据库操作时指定 transaction 参数为该实例，这样就可以在事务下进行数据库操作。当事务完成后，通过 commit 方法提交事务，通过 rollback 方法回滚。例如： 123456789101112131415161718192021sequelize.transaction(&#123; isolationLevel: Sequelize.Transaction.ISOLATION_LEVELS.READ_COMMITTED&#125;, transaction =&gt; &#123; return User.findOne(&#123; where: &#123; name: '小明' &#125;, transaction: t &#125;).then(function(model) &#123; if (model) &#123; model.age = model.age + 1; return model.save(&#123; transaction: t &#125;); &#125; &#125;);&#125;).then(result =&gt; &#123; // transaction has been committed. Do something after the commit if required.&#125;).catch(err =&gt; &#123; // do something with the err.&#125;); 创建事务时可以通过 isolationLevel 参数指定事务的隔离级别，默认级别是 REPEATABLE_READ。 给 sequelize.transaction 方法指定回调函数可以将事务托管给 Sequelize，它会自动提交和回滚事务（例如上面的例子）。如果不使用回调函数的写法，而是使用 promise.then()，则需要手动调用 t.commit() 提交事务，t.callback() 回滚事务。 总结目前，我也只是使用了 Sequelize 的一些基本功能，并不涉及到复杂的操作，不太适合过多的进行评价，给我的感觉还是相当不错的，简单、好用。]]></content>
      <categories>
        <category>技术</category>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>ORM</tag>
        <tag>Sequelize</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库事务及锁机制]]></title>
    <url>%2F2017%2F09%2Fdatabase-transaction%2F</url>
    <content type="text"><![CDATA[昨天，在实际的开发过程中，有一个从数据库中取一条数据的操作，需要保证每条数据只会被取用一次。最终，通过数据库事务解决了该问题。在解决的过程中，可以说是重新的学习了一遍数据库锁机制和事务，补了个钙。 前言在实现该功能时，首先在数据库表中添加了一个 is_used 字段，用来是标记该条数据是否被使用过，其中为 1 时表示已使用，为 0 时表示尚未被使用。每次获取一条可用数据的同时，需要将该条数据的 is_used 字段置为 1，表示该条数据已经被使用了。在这种情况下，在多个获取数据的请求并发执行的过程中，可能前一个请求处理过程中还未来得及将 is_used 字段置为 1，下一个请求就到来，导致两个请求获取到同一条数据。 最初，计划是通过在内存中维护一个队列，队列中缓存了部分可用的数据。当一个请求到来时，从队列中取出一个可用数据返回给客户端，并将该条数据对应的 is_used 字段置为 1。通过这样的方式，将并发的取数操作变为了同步的队列操作，可以保证不会取到同一条数据。 后来，在开始实现时考虑到是否可以从数据库层面实现这个问题？能不能确保获取一条数据并设置 is_used 字段为 1 的过程中，其他的请求不会取到该条数据？最后，突然想到了数据库的事务，因为事务具有原子性和隔离性，正好可以应对这种并发的情况。 数据库锁机制关于数据库锁经常会听到”共享锁”、”排他锁”、”乐观锁”、”行级锁”等名词，之前并不是很熟悉，借着这次机会我重新的了解了一下数据库锁机制。数据库锁主要分为以下几类： 按锁的粒度划分，可分为行级锁、表级锁、页级锁。 按锁级别划分，可分为共享锁、排他锁。 按使用方式划分，可分为乐观锁、悲观锁 按操作划分，可分为 DML 锁和 DDL 锁。 按加锁方式划分，可分为自动锁、显示锁 行级锁、表级锁和页级锁行级锁是锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁和排他锁。 表级锁是锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少。表级锁定分为表共享读锁和表独占写锁。 页级锁是锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。页级锁选择了一个折中的方案，一次锁定相邻的一组记录。 共享锁和排他锁共享锁共享锁又称 S 锁、读锁，是读取操作创建的锁。加上共享锁后，其他用户可以并发读取数据（继续加共享锁），但不能对数据进行修改（无法加排他锁），直到所有共享锁被释放。 排它锁排他锁又称 X 锁、写锁，如果想到修改数据，必须先获得排他锁，获得排他锁的事务可以读、写数据。在给数据加上排它锁之后，其他事务不能再添加其他任何类型的锁。 乐观锁和悲观锁乐观锁和悲观锁不是数据库中的概念，而是人们定义出来的概念，用来描述数据库并发控制的方案。 乐观锁乐观锁假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。在进行数据库处理时，乐观锁通常不使用数据库提供的锁机制，而是给数据添加一个版本标识，在读取数据时连同版本标识一同读出，然后再更新数据时检查当前标识与第一次读取出来的标识进行对比，如果相同则进行更新，否则认为数据过期。 悲观锁悲观锁指的是对数据是否可能被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守（悲观）态度，认为在自己的处理过程中，数据往往都会被外界修改，因此，在整个数据处理过程中，将数据处于锁定状态。 DML 锁和 DDL 锁DML(Data Manipulation Language)指数据操纵语言，在对数据进行操作（DML 操作）是会自动加上 DML 锁，如 insert、delete、update、select 等， DDL(Data Definition Language)指数据定义语言，在进行数据库定义操作（DDL 操作）时会自动加上 DDL 锁如 create、alert、drop 等。 事务数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。一个逻辑工作单元要成为事务，必须满足所谓的 ACID（原子性、一致性、隔离性和持久性）属性。 原子性原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，使多个数据库操作看起来像一个操作一样。 一致性一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。 隔离性隔离性是当多个用户并发访问数据库时，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。事务的隔离有 4 中级别，由低到高分别为 Read uncommitted 、Read committed 、Repeatable read 、Serializable。 Read uncommitted：顾名思义指一个事务会读取到另一个事务中未提交的读取，会产生脏读问题。 Read committed：顾名思义指一个事务只会读取到另一个事务提交后的数据，可以解决脏读问题，但是会产生不可重复读问题。 Repeatable read：意思是说可重复读，为了解决不可重复读的问题而产生。这里重复读指的是在一个事务执行过程中，多次对一条数据进行读取操作。其中不可重复读指多次读取操作中会读取到不同的数据，而可重复读指多次读取操作中读取的是相同的数据。这里针对的时同一条数据，如果是插入一条新的数据，那么无法进行控制，因此会产生幻读。 Serializable：最高的事务隔离级别，在该级别下，多个事务顺序执行，可以解决幻读问题。 持久性持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。 实际应用在补充了数据库锁机制及事务相关的知识后，再来看之前的问题就变得简单许多。在这个问题中，我们需要保证获取一个 is_used 字段为 0 的数据并将该数据的该字段设置为 1 是一个原子操作，并且不会被其他并发操作影响。因此，我们只用把查询数据和更新操作放在一个事务种并设置合适的隔离级别即可。那么，事务的隔离级别应该设置为哪个呢？ 其实，这里的关键点在于，一个事务在读取一条可用数据并将其设为不可用状态之前，如果后来的事务也读取到了相同的数据，那么该事务的更新操作不能完成。也就是说，前面的事务执行过程中，不会读取到后一个事务提交的数据，对应的隔离级别就是 Repeatable read。如果用锁机制来解释，就是事务开始时，给读取到的数据加上排他锁，直到完成数据的更新操作后释放。这样，其他事务只能读取到该事务执行前或者执行完成后的数据。 关于事务的具体使用见我的另一篇博客：Sequelize 基本用法 参考链接 http://blog.csdn.net/lexang1/article/details/52248686 http://www.cnblogs.com/fjdingsd/p/5273008.html]]></content>
      <categories>
        <category>技术</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[问题汇总]]></title>
    <url>%2F2017%2F09%2Fsolution%2F</url>
    <content type="text"><![CDATA[学习、工作当中常常会遇到一些问题，有的问题第一次遇到不知道如何解决就会去百度、谷歌。但是，有的一些问题我发现当我再次遇到的时候，仍然无法第一时间解决它，因为我忘记了具体操作或者是一些命令。所以，我决定把我通过百度、谷歌才解决的一些问题记录在博客当中，当我再次遇到而又记不清具体怎么解决的时候，就可以直接翻看这篇博客而不用再在网上花时间找解决办法。 NPMError with code: EINTEGRITY通过 npm install 安装依赖时出现上述错误代码，百度说通过 npm cache clean --force 清除缓存，但是这对我来说没有作用。最后，Google 到 npm 的 issues，删除 package-lock.json 解决了该问题。 WebStorm在 Webpack 中配置别名后，WebStorm 出现文件找不到的提示WebStorm 2017.2 EAP, 172.2827 版本已经支持，它会自动解析项目根目录下的 Webpack 配置文件，在 Preferences/Languages &amp; Frameworks/JavaScript/Webpack 中可以指定配置文件。 参考：https://blog.jetbrains.com/webstorm/2017/06/webstorm-2017-2-eap-172-2827/ React热模块替换失效原因：我在导入 containers/App/App.js 时导入了全部的 containers。 解决办法：在导入时只导入 App 组件即可。如下面代码所示： 1234567891011121314151617181920212223import React from 'react';import ReactDOM from 'react-dom';import &#123;AppContainer&#125; from 'react-hot-loader';// import &#123;App&#125; from 'containers';import App from 'containers/App/App';const render = (RootElement) =&gt; &#123; ReactDOM.render( &lt;AppContainer&gt; &lt;RootElement/&gt; &lt;/AppContainer&gt; , document.getElementById('root'));&#125;;if (module.hot) &#123; module.hot.accept('containers/App/App', () =&gt; &#123; const App = require('containers/App/App').default; render(App); &#125;);&#125;render(App); 使用 Eslint 时出现变量未使用的错误安装 eslint-plugin-eact 插件，配置 extends 属性如下： 1234"extends": [ "standard", "plugin:react/recommended" ]]]></content>
      <categories>
        <category>收藏</category>
      </categories>
      <tags>
        <tag>WebStorm</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域 POST 请求之 CROS]]></title>
    <url>%2F2017%2F09%2Fcors%2F</url>
    <content type="text"><![CDATA[跨域资源共享（Cross-origin resource sharing，简称 “CROS”）是一个新的 W3C 标准，它允许浏览器跨域请求服务器上的资源，就像请求同源的服务器资源一样。对于跨域问题常见的解决方法就是使用 JSONP，但是 JSONP 是不支持 POST 请求的，在 jQeury 中即使设置为 POST 也依旧会以 GET 请求提交。当不需要兼容低版本浏览器时，相较于 iframe、proxy 等，CROS 不失为一个简单、优雅的解决方案。 前言最近在项目中需要跨域提交 POST 请求，使用的是 CROS 作为解决方案。之前对于 CROS 有过一些了解，但没有具体的尝试使用，只是觉得 CROS 机制并不复杂：无外乎就是提供了一种跨域请求资源时，如果服务器同意就允许此次请求的机制。但是，这次在具体使用时却遇到了麻烦。 基本使用CROS 使用起来十分简单，前端不需要做任何处理，只需要服务器在响应请求时，在响应头中设置几个特殊的字段即可，具体是哪些字段根据请求类的型不同而不同。 利用 CROS 跨域请求被分为两种：一种是不需要进行预检的简单请求，另一种是需要进行预检的非简单请求。简单请求和非简单请求主要通过请求类型和请求头进行决定，如果请求满足下面的条件就是简单请求，否则就是非简单请求。 请求方法是 HEAD、GET 或者 POST 方法。 请求头中只包含这些头：Accept、Accept-Language、Content-Language、Last-Event-ID 和 Content-Type，其中 Content-Type 的值只能是 application/x-www-form-urlencoded、multipart/form-data 或者 text/plain。 简单请求对于简单请求，浏览器在发出请求时会在请求头中添加一个 Origin 字段用来说明本次请求来自哪个源，服务器可以根据这个字段来决定是否允许此次访问。 如果服务器同意此次请求，那么在响应头中会包含 Access-Control-Allow-Origin 字段，浏览器发现响应头中包含该字段，就知道这个请求是被允许的。相反地，如果服务器拒绝了本次请求，那么在响应头中就不会包含该字段，这时浏览器就会抛出一个错误。 非简单请求非简单请求相较于简单请求而言最大的区别就是有一个预检的过程，即浏览器在发出正式的请求之前会先发出一个 OPTIONS 请求，该请求的作用是先询问服务器当前域是否可以访问以及是否允许此类方法和其他的请求头字段，当服务器中的响应头中包含允许此请求的字段，浏览器才会发出正式的请求。 实际应用在这次实际应用过程中，我起初并不清楚发送 POST 请求之前有一个预检的过程，我简单的以为只需要服务端在返回时添加对应的头即可，但是 POST 请求一直不成功，如果换成 GET 请求则可以正常请求，这一度让我百思不得其解。 浏览器上报的错误就是没有跨域的权限，但是其实在那之前还有一个 401。我注意到了这一点，但是我以为这是因为没有权限所以才返回的 401。但是，其实是因为服务端有鉴权的过程，而 OPTIONS 请求鉴权没有通过，所以服务端直接返回了 401，没有执行到设置响应头的处理，这才导致一直请求不成功。 后面，将服务端中对于 OPTIONS 请求的鉴权去掉就可以成功跨域了。 总结这次问题其实是一个很小的问题，在解决的过程中之所以花了过多的时间就是因为我想当然了，明明就不是很清楚，自以为 401 是因为没有跨域权限导致的。所以，以后在遇到问题时还是不能太想当然，可以进行适当的猜测，但是一定要去验证猜测的正确性。如果能又快又对的定位问题的原因，可以节省大量摸石头过河的过程。🤡🤡]]></content>
      <categories>
        <category>技术</category>
        <category>Web 通信</category>
      </categories>
      <tags>
        <tag>CROS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 学习笔记]]></title>
    <url>%2F2017%2F09%2Fnote-react%2F</url>
    <content type="text"><![CDATA[这篇文章是我在学习 React 的过程中记录下的笔记，学习主要是跟着官网的文档了解 React 的一些基本用法。我记录下了在这个过程中我遇到过的问题以及我觉得重要的地方。 安装通过引入脚本文件的方式安装时，需要先引入 React，再引入 ReactDOM。 JSXReact 中使用了叫做 JSX 的一种 JavaScript 语法扩展，感觉和模板语言很类似，通过 JSX 可以告别传统的通过拼接字符串或者是数据中 push 标签的方式来构建页面，更加的直观、优雅。 在 JSX 中可以直接像书写 HTML 一样写页面，可以任意地使用 JavaScript 表达式，表达式需要用 {} 括起来。 推荐在 JSX 代码的外面扩上一个小括号，这样可以防止自动插入分号（简称 ASI）的问题。下面是一个典型的例子： 123456function asi()&#123; return 'Test ASI';&#125;asi(); // undefined JSX 在编译之后也会转化成 JavaScript 对象，因此可以直接将其赋值给变量或者作为函数的参数和返回值。 React DOM 使用 camelCase 驼峰命名来定义属性的名称，而不是使用 HTML 的属性名称。例如：使用 className 指代 HTML class 属性。 可以使用 JSX 中的点表示法来引用 React 组件，例如： 1234567891011import React from 'react';const MyComponents = &#123; DatePicker: function DatePicker(props) &#123; return &lt;div&gt;Imagine a &#123;props.color&#125; datepicker here.&lt;/div&gt;; &#125;&#125;function BlueDatePicker() &#123; return &lt;MyComponents.DatePicker color="blue" /&gt;;&#125; 如果你没有给属性传值，它默认为 true。例如： 123456&lt;MyTextBox autocomplete /&gt;&lt;!-- 不推荐这样使用，因为它会与 ES6 对象简洁表示法 混淆。比如 &#123;foo&#125; 是 &#123;foo: foo&#125; 的简写--&gt;&lt;MyTextBox autocomplete=&#123;true&#125; /&gt; 元素元素是构成 React 应用的最小单位。React 元素在写法上看上去像是 HTML 标签，但是不同于浏览器 DOM 元素，实际上只是一个 JavaScript 对象。 React 元素都是不可变的，当元素被渲染之后就无法再改变元素的内容或者属性，更新的唯一方法就是渲染一个新的元素。React 中使用了虚拟 DOM，在重新渲染的时候不会更新全部的元素，而是会先比较前后差异，只更新改变了的部分。 条件渲染React 中的条件渲染核心就是通过控制组件 render 的返回值来实现的，而不是像其他框架有 if 指令。 render 中 return null 可以隐藏组件，阻止组件渲染，这并不会影响该组件生命周期方法的回调。 循环渲染React 可以直接渲染出由 React 元素构成的集合。例如： 123456789const numbers = [1, 2, 3, 4, 5];const listItems = numbers.map((number) =&gt; &lt;li&gt;&#123;number&#125;&lt;/li&gt;);ReactDOM.render( &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;, document.getElementById('body')); 当使用元素集合时，应当给数组中的每一个元素赋予一个确定的标识，称为 “key”。Keys 可以在 DOM 中的某些元素被增加或删除的时候帮助 React 识别数组中哪些元素发生了变化。 注意： key 不会传递给组件，即通过 props.key 无法获取到 key。 数组元素中使用的 key 在其兄弟之间应该是独一无二的，但不必全局唯一。 组件及属性组件就像是一个函数，接受一个被成为组件属性的输入，返回一个 React 元素。例如： 123function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125; 上面的这个函数就是一个 React 组件，我们也可以使用 ES6 class 来定义组件： 12345class Welcome extends React.Component &#123; render()&#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;; &#125;&#125; 定义了组件后，可以直接像使用 HTML 标签一样使用该组件。同时，使用组件时在组件上定义的所有属性会通过一个 props 对象传递给该组件。 注意： 组件名称必须以大写字母开头 组件的返回值只能有一个根元素 不能修改组件的 props 在我看来，一个组件应该是一个具有特定功能、低耦合、可单独工作的单元。组件应该具有较好的通用性，与上下文的不应该过度的关联。 受控组件值由 React 控制的输入表单元素称为“受控组件”。例如： 123456789101112131415161718192021222324252627class Input extends React.Component &#123; constructor(props)&#123; super(props); this.state = &#123; value: '' &#125;; this.handleChange = this.handleChange.bind(this); &#125; handleChange(e) &#123; this.setState(&#123; value: e.target.value.toLocaleUpperCase() &#125;); &#125; render() &#123; return ( &lt;input value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt; ); &#125;&#125;ReactDOM.render( &lt;Input /&gt;, document.querySelector('body')); 组件组合组件 JSX 标签内的任何内容都将通过 children 属性传入。 可以将一个组件作为另一个组件的属性传入，完全各种组件的组合，例如： 123456789101112131415161718192021222324function SplitPane(props) &#123; return ( &lt;div className="SplitPane"&gt; &lt;div className="SplitPane-left"&gt; &#123;props.left&#125; &lt;/div&gt; &lt;div className="SplitPane-right"&gt; &#123;props.right&#125; &lt;/div&gt; &lt;/div&gt; );&#125;function App() &#123; return ( &lt;SplitPane left=&#123; &lt;Contacts /&gt; &#125; right=&#123; &lt;Chat /&gt; &#125; /&gt; );&#125; 组件可以接受任意元素，包括基本数据类型、React 元素或函数。 如果要在组件之间复用 UI 无关的功能，我们建议将其提取到单独的 JavaScript 模块中。这样可以在不对组件进行扩展的前提下导入并使用该函数、对象或类。 属性类型检查 使用 Flow 或者 TypeScript这样的 JavsScript 扩展来对整个应用程序进行类型检查。 使用 prop-types 库。 生命周期装载 constructor：构造函数，在创建组件时调用一次。 componentWillMount：组件被挂载在页面之前调用。 componentDidMount：组件挂载在页面之后调用。 更新 componentWillReceiveProps：组件接收到新属性前调用。 shouldComponentUpdate：状态改变时调用，默认返回 true ，需要重新渲染。可以再这里做判断返回 false 阻止渲染。 componentWillUpdate：shouldComponentUpdate 返回 rue 或者调用forceUpdate之后，在渲染前被立即调用。初始化渲染时不会调用。 componentDidUpdate：在更新发生后立即被调用，不会在初始化渲染时调用。 卸载 componentWillUnmount：当一个组件从 DOM 中被移除时，该方法被调用。一般在 componentDidMount 里面注册的事件需要在这里删除。 状态状态与属性十分相似，但是状态是私有的，完全由组件自己控制。 对于组件中不需要输出到页面上的属性，不要将属性添加到 props 或者 state 上面，而是直接作为组件的属性添加到 this 上。 注意： 不要直接的修改状态，而是使用 setState 方法 状态更新可能是异步的 调用 setState() 时，React 会将对象合并到当前状态。 向下的单项数据流，属性只能由父组件到子组件。这点和 Polymer 不一样。 状态提升在React中，状态分享是通过将 state 数据提升至离需要这些数据的组件最近的父组件来完成的。这就是所谓的状态提升。 通过状态提升，可以进行子组件间的通信。我们可以把子组件看作是一个 HTML 元素，这就类似于前面提到的受控组件：由父组件进行状态管理，将属性通过 props 传递给需要通信的子组件，这样子组件就可以拥有一致的数据，因为属性通过 props 传递给子组件，子组件是不能直接进行修改的，所以同时传递一个处理函数给相应的子组件。 事件React 组件上绑定的写法与原生写法类似，只是事件名称使用驼峰命名，并将一个函数传入，而原生写法使用的是事件名小写并传入一个字符串。如下： 123456789// 原生写法&lt;button onclick="doClick()"&gt; Click Me!&lt;/button&gt;// React 写法&lt;button onClick=&#123;doClick&#125;&gt; Click Me!&lt;/button&gt; React 在事件处理中阻止浏览器默认行为不能使用 return false，只能使用 e.preventDefault()。 使用 ES6 class 语法来定义一个组件的时候，事件处理器会成为类的一个方法。绑定事件时需要注意 this 的指向。推荐在构造函数中绑定 this 或使用属性初始化器语法。如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class ToggleButton extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; isToggleOn: true &#125;; this.handleClick = this.handleClick.bind(this); &#125; handleClick() &#123; /* * 状态的更新可能是异步的，因此最好不要直接使用当前状态来计算下一个状态。 * setState 支持传入一个函数，函数中会将上次状态作为参数传入，推荐使用此种方式。 * * this.setState(&#123; * isToggleOn: !this.state.isToggleOn * &#125;); */ this.setState(prevState =&gt; (&#123; isToggleOn: !prevState.isToggleOn &#125;)); &#125; render() &#123; return ( /* * 绑定事件时，注意 this 的指向，需要绑定 this： * this.handClick.bind(this) 或 (e) =&gt; this.handleClick(e) * * 使用这种方式在 ToggleButton 渲染的时候都会创建一个新的函数，如果这个函数作为属性传入子组件，那么组件可能会进行额外的重新渲染。 * 因此，推荐在构造函数中绑定 this 或使用属性初始化器语法 */ &lt;button onClick=&#123;this.handleClick&#125;&gt; &#123;this.state.isToggleOn ? 'On' : 'Off'&#125; &lt;/button&gt; ); &#125;&#125;ReactDOM.render( &lt;ToggleButton /&gt;, document.querySelector('body')); 属性初始化器语法如下： 123456789101112131415class LoggingButton extends React.Component &#123; // This syntax ensures `this` is bound within handleClick. // Warning: this is *experimental* syntax. handleClick = () =&gt; &#123; console.log('this is:', this); &#125; render() &#123; return ( &lt;button onClick=&#123;this.handleClick&#125;&gt; Click me &lt;/button&gt; ); &#125;&#125; 其他Ref通过 Ref 我们可以直接操作 DOM 元素或者子组件。例如： 123456789101112class AutoFocusTextInput extends React.Component &#123; componentDidMount() &#123; this.textInput.focus(); &#125; render() &#123; return ( &lt;CustomTextInput ref=&#123;(input) =&gt; &#123; this.textInput = input; &#125;&#125; /&gt; ); &#125;&#125; 给 HTML 元素添加 ref 属性时，ref 回调接收了底层的 DOM 元素作为参数；给组件添加 ref 属性时，参数是组件的实例，仅对 class 声明的 CustomTextInput 有效。 想要在父组件内直接操作子组件的 DOM 元素，可以在子组件上添加 ref 属性，然后父组件把函数作为参数传入，例如： 1234567891011121314151617function CustomTextInput(props) &#123; return ( &lt;div&gt; &lt;input ref=&#123;props.inputRef&#125; /&gt; &lt;/div&gt; );&#125;class Parent extends React.Component &#123; render() &#123; return ( &lt;CustomTextInput inputRef=&#123;el =&gt; this.inputElement = el&#125; /&gt; ); &#125;&#125; 非受控组件 在受控组件中，表单数据由 React 组件处理。如果让表单数据由 DOM 处理时，替代方案为使用非受控组件。受控组件通过 ref 从 DOM 获取表单值；通过 defaultValue 属性指定默认值，而不是 value，checkbox 和 radio 则是 defaultChecked。]]></content>
      <categories>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[彻底弄懂 Unicode 编码]]></title>
    <url>%2F2017%2F09%2Fencoded%2F</url>
    <content type="text"><![CDATA[今天，在学习 Node.js 中的 Buffer 对象时，注意到它的 alloc 和 from 方法会默认用 UTF-8 编码，在数组中每位对应 1 字节的十六进制数。想到了之间学习 ES6 时关于字符串的 Unicode 表示法，突然就很想知道 UTF-16 是如何进行编码的，我尝试将一些汉字转换成二进制数，然后简单的按 2 个字节一组转换成十六进制，发现对于那些码点较大的汉字，结果并不仅仅是简单的二进制转十六进制。于是，我开始在网上找资料，决心彻底弄明白 Unicode 编码。 ASCII码在学校学 C 语言的时候，了解到一些计算机内部的机制，知道所有的信息最终都表示为一个二进制的字符串，每一个二进制位有 0 和 1 两种状态，通过不同的排列组合，使用 0 和 1 就可以表示世界上所有的东西，感觉有点中国“太极”的感觉——“太极生两仪，两仪生四象，四象生八卦”。 在计算机种中，1 字节对应 8 位二进制数，而每位二进制数有 0、1 两种状态，因此 1 字节可以组合出 256 种状态。如果这 256 中状态每一个都对应一个符号，就能通过 1 字节的数据表示 256 个字符。美国人于是就制定了一套编码（其实就是个字典），描述英语中的字符和这 8 位二进制数的对应关系，这被称为 ASCII 码。 ASCII 码一共定义了 128 个字符，例如大写的字母 A 是 65（这是十进制数，对应二进制是0100 0001）。这 128 个字符只使用了 8 位二进制数中的后面 7 位，最前面的一位统一规定为 0。 历史问题英语用 128 个字符来编码完全是足够的，但是用来表示其他语言，128 个字符是远远不够的。于是，一些欧洲的国家就决定，将 ASCII 码中闲置的最高位利用起来，这样一来就能表示 256 个字符。但是，这里又有了一个问题，那就是不同的国家的字符集可能不同，就算它们都能用 256 个字符表示全，但是同一个码点（也就是 8 位二进制数）表示的字符可能可能不同。例如，144 在阿拉伯人的 ASCII 码中是 گ，而在俄罗斯的 ASCII 码中是 ђ。 因此，ASCII 码的问题在于尽管所有人都在 0 - 127 号字符上达成了一致，但对于 128 - 255 号字符上却有很多种不同的解释。与此同时，亚洲语言有更多的字符需要被存储，一个字节已经不够用了。于是，人们开始使用两个字节来存储字符。 各种各样的编码方式成了系统开发者的噩梦，因为他们想把软件卖到国外。于是，他们提出了一个“内码表”的概念，可以切换到相应语言的一个内码表，这样才能显示相应语言的字母。在这种情况下，如果使用多语种，那么就需要频繁的在内码表内进行切换。 Unicode最终，美国人意识到他们应该提出一种标准方案来展示世界上所有语言中的所有字符，出于这个目的，Unicode诞生了。 Unicode 当然是一本很厚的字典，记录着世界上所有字符对应的一个数字。具体是怎样的对应关系，又或者说是如何进行划分的，就不是我们考虑的问题了，我们只用知道 Unicode 给所有的字符指定了一个数字用来表示该字符。 对于 Unicode 有一些误解，它仅仅只是一个字符集，规定了符合对应的二进制代码，至于这个二进制代码如何存储则没有任何规定。它的想法很简单，就是为每个字符规定一个用来表示该字符的数字，仅此而已。 Unicode 编码方案之前提到，Unicode 没有规定字符对应的二进制码如何存储。以汉字“汉”为例，它的 Unicode 码点是 0x6c49，对应的二进制数是 110110001001001，二进制数有 15 位，这也就说明了它至少需要 2 个字节来表示。可以想象，在 Unicode 字典中往后的字符可能就需要 3 个字节或者 4 个字节，甚至更多字节来表示了。 这就导致了一些问题，计算机怎么知道你这个 2 个字节表示的是一个字符，而不是分别表示两个字符呢？这里我们可能会想到，那就取个最大的，假如 Unicode 中最大的字符用 4 字节就可以表示了，那么我们就将所有的字符都用 4 个字节来表示，不够的就往前面补 0。这样确实可以解决编码问题，但是却造成了空间的极大浪费，如果是一个英文文档，那文件大小就大出了 3 倍，这显然是无法接受的。 于是，为了较好的解决 Unicode 的编码问题， UTF-8 和 UTF-16 两种当前比较流行的编码方式诞生了。当然还有一个 UTF-32 的编码方式，也就是上述那种定长编码，字符统一使用 4 个字节，虽然看似方便，但是却不如另外两种编码方式使用广泛。 UTF-8UTF-8 是一个非常惊艳的编码方式，漂亮的实现了对 ASCII 码的向后兼容，以保证 Unicode 可以被大众接受。 UTF-8 是目前互联网上使用最广泛的一种 Unicode 编码方式，它的最大特点就是可变长。它可以使用 1 - 4 个字节表示一个字符，根据字符的不同变换长度。编码规则如下： 对于单个字节的字符，第一位设为 0，后面的 7 位对应这个字符的 Unicode 码点。因此，对于英文中的 0 - 127 号字符，与 ASCII 码完全相同。这意味着 ASCII 码那个年代的文档用 UTF-8 编码打开完全没有问题。 对于需要使用 N 个字节来表示的字符（N &gt; 1），第一个字节的前 N 位都设为 1，第 N + 1 位设为0，剩余的 N - 1 个字节的前两位都设位 10，剩下的二进制位则使用这个字符的 Unicode 码点来填充。 编码规则如下： Unicode 十六进制码点范围 UTF-8 二进制 0000 0000 - 0000 007F 0xxxxxxx 0000 0080 - 0000 07FF 110xxxxx 10xxxxxx 0000 0800 - 0000 FFFF 1110xxxx 10xxxxxx 10xxxxxx 0001 0000 - 0010 FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 根据上面编码规则对照表，进行 UTF-8 编码和解码就简单多了。下面以汉字“汉”为利，具体说明如何进行 UTF-8 编码和解码。 “汉”的 Unicode 码点是 0x6c49（110 1100 0100 1001），通过上面的对照表可以发现，0x0000 6c49 位于第三行的范围，那么得出其格式为 1110xxxx 10xxxxxx 10xxxxxx。接着，从“汉”的二进制数最后一位开始，从后向前依次填充对应格式中的 x，多出的 x 用 0 补上。这样，就得到了“汉”的 UTF-8 编码为 11100110 10110001 10001001，转换成十六进制就是 0xE6 0xB7 0x89。 解码的过程也十分简单：如果一个字节的第一位是 0 ，则说明这个字节对应一个字符；如果一个字节的第一位1，那么连续有多少个 1，就表示该字符占用多少个字节。 UTF-16在了解 UTF-16 编码方式之前，先了解一下另外一个概念——“平面”。 在上面的介绍中，提到了 Unicode 是一本很厚的字典，她将全世界所有的字符定义在一个集合里。这么多的字符不是一次性定义的，而是分区定义。每个区可以存放 65536 个（$2^{16}$）字符，称为一个平面（plane）。目前，一共有 17 个（$2^{5}$）平面，也就是说，整个 Unicode 字符集的大小现在是 $2^{21}$。 最前面的 65536 个字符位，称为基本平面（简称 BMP ），它的码点范围是从 0 到 $2^{16}-1$，写成 16 进制就是从 U+0000 到 U+FFFF。所有最常见的字符都放在这个平面，这是 Unicode 最先定义和公布的一个平面。剩下的字符都放在辅助平面（简称 SMP ），码点范围从 U+010000 到 U+10FFFF。 基本了解了平面的概念后，再说回到 UTF-16。UTF-16 编码介于 UTF-32 与 UTF-8 之间，同时结合了定长和变长两种编码方法的特点。它的编码规则很简单：基本平面的字符占用 2 个字节，辅助平面的字符占用 4 个字节。也就是说，UTF-16 的编码长度要么是 2 个字节（U+0000 到 U+FFFF），要么是 4 个字节（U+010000 到 U+10FFFF）。那么问题来了，当我们遇到两个字节时，到底是把这两个字节当作一个字符还是与后面的两个字节一起当作一个字符呢？ 这里有一个很巧妙的地方，在基本平面内，从 U+D800 到 U+DFFF 是一个空段，即这些码点不对应任何字符。因此，这个空段可以用来映射辅助平面的字符。 辅助平面的字符位共有 $2^{20}$ 个，因此表示这些字符至少需要 20 个二进制位。UTF-16 将这 20 个二进制位分成两半，前 10 位映射在 U+D800 到 U+DBFF，称为高位（H），后 10 位映射在 U+DC00 到 U+DFFF，称为低位（L）。这意味着，一个辅助平面的字符，被拆成两个基本平面的字符表示。 因此，当我们遇到两个字节，发现它的码点在 U+D800 到 U+DBFF 之间，就可以断定，紧跟在后面的两个字节的码点，应该在 U+DC00 到 U+DFFF 之间，这四个字节必须放在一起解读。 接下来，以汉字”𠮷”为例，说明 UTF-16 编码方式是如何工作的。 汉字”𠮷”的 Unicode 码点为 0x20BB7，该码点显然超出了基本平面的范围（0x0000 - 0xFFFF），因此需要使用四个字节表示。首先用 0x20BB7 - 0x10000 计算出超出的部分，然后将其用 20 个二进制位表示（不足前面补 0 ），结果为0001000010 1110110111。接着，将前 10 位映射到 U+D800 到 U+DBFF 之间，后 10 位映射到 U+DC00 到 U+DFFF 即可。U+D800 对应的二进制数为 1101100000000000，直接填充后面的 10 个二进制位即可，得到 1101100001000010，转成 16 进制数则为 0xD842。同理可得，低位为 0xDFB7。因此得出汉字”𠮷”的 UTF-16 编码为 0xD842 0xDFB7。 Unicode3.0 中给出了辅助平面字符的转换公式： 123H = Math.floor((c-0x10000) / 0x400)+0xD800L = (c - 0x10000) % 0x400 + 0xDC00 根据编码公式，可以很方便的计算出字符的 UTF-16 编码。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Unicode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js 实现百度主动推送]]></title>
    <url>%2F2017%2F09%2Fbaidu-push%2F</url>
    <content type="text"><![CDATA[博客建立好之后，迟迟没有被百度收录。之前添加了站点地图和 NexT 主题提供的主动推送，看到百度站长平台还支持一个主动推送功能，说是能使提交的页面被更快的收录。于是，就用 Node.js 写了一个主动推送的小工具，该工具会提取指定网站 sitemap.xml 中的 url 并将所有提取到的 url 通过百度站长提供的主动推送接口推送给百度。 如何使用我将脚本提交到了 GitHub 仓库中，该仓库中还包含了一些其他我用到的脚本(仓库地址戳这里）。直接将该仓库克隆到本地，然后进入到脚本文件所在目录，安装需要的依赖并执行脚本即可。 1234$ git clone git@github.com:hezhii/scripts.git$ cd scripts/nodejs/pushurl$ yarn install$ URL=&lt;your_site_url&gt; TOKEN=&lt;your_baidu_token&gt; node index.js 注意：运行本脚本需要安装 Node.js 和 Yarn。 定时启动在完成这个脚本后，我想每天能定时的推送一次博客中的文章。于是，就上网了解了一下 macOS 上计划任务相关的内容，网上有几种解决思路。最终我选择了使用 crontab 创建定时任务。 crontab 是一个定时任务的调度工具，我们可以通过编辑定时任务列表文件将任务添加到 crontab中。定时任务的格式如下： 1234567* * * * * &lt;command to execute&gt;│ │ │ │ ││ │ │ │ └─── day of week (0 - 6) (0 to 6 are Sunday to Saturday, or use names; 7 is Sunday, the same as 0)│ │ │ └──────── month (1 - 12)│ │ └───────────── day of month (1 - 31)│ └────────────────── hour (0 - 23)└─────────────────────── min (0 - 59) 下面我以设置每天上午 10 点执行主动推送脚本为例进行说明。 首先在终端输入 crontab -e 打开定时任务文件，然后按 i 编辑该文件，在文件的第一行插入下面内容： 10 10 * * * PATH=/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin;URL=your_site_url TOKEN=your_baidu_token ~/Development/projects/tools/nodejs/pushurl/index.js &gt;&gt; ~/Desktop/push_log.txt 2&gt;&amp;1 然后直接 :wq 保存并退出即可。我们可以在终端输入 crontab -l 查看已添加的定时任务。 根据上面的命令格式可以看出，内容的意思是说在每天的 10 点 执行PATH=/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin;URL=your_site_url TOKEN=your_baidu_token ~/Development/projects/tools/nodejs/pushurl/index.js &gt;&gt; ~/Desktop/push_log.txt 2&gt;&amp;1 命令。这行命令首先添加了 PATH，因为 crontab 在执行时的 PATH 是 usr/bin，可能会导致 node 命令不存在。然后设置了 URL 和 TOKEN 两个环境变量，用来指定站点和相应的接口 Token。最后，直接执行了百度推送脚本（需要先通过 chmod 添加脚本执行权限），并将结果输出到了桌面上的 puth_log.txt 文件中。 我们也可以不用上面的命令，直接使用 &lt;node_home&gt;/node &lt;script_home&gt;/index.js 执行脚本，其中 node_path 使用绝对路径。 如何实现实现起来十分的简单，首先请求网站的站点地图文件，然后解析 xml 文件提取欲提交的 url。最后，直接调用百度站长上的提供的接口，发送一个 POST 请求即可。具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#!/usr/bin/env nodeconsole.log(`[$&#123;new Date().toLocaleString()&#125;] -- 开始推送`);const request = require('request');const parseString = require('xml2js').parseString;const URL = process.env.URL; // 提交到百度的网址const TOKEN = process.env.TOKEN; // 百度站长主动推送tokenfetchUrlDatas().then(urls =&gt; push(urls));function push(urls) &#123; if (!urls || !urls.length) &#123; console.error('欲推送的地址数目不能为空'); return; &#125; const options = &#123; url: `http://data.zz.baidu.com/urls?site=$&#123;URL&#125;&amp;token=$&#123;TOKEN&#125;`, method: 'POST', headers: &#123; 'Content-Type': 'text/plain', &#125;, body: urls.join('\n') &#125;; request(options, (err, res, body) =&gt; &#123; if (err) &#123; console.error(`推送Url时遇到问题: $&#123;err.message&#125;`); &#125; else &#123; let result = JSON.parse(body); console.log(`[$&#123;new Date().toLocaleString()&#125;] -- 推送完成。成功推送 $&#123;result.success&#125; 条url，今天剩余 $&#123;result.remain&#125; 条可推送url。`); console.log('------------------------------------'); &#125; &#125;);&#125;function fetchUrlDatas() &#123; return new Promise((resolve, reject) =&gt; &#123; request(`http://$&#123;URL&#125;/sitemap.xml`, (err, res, body) =&gt; &#123; if (err) &#123; console.error(`获取sitemap时遇到问题: $&#123;err.message&#125;`); reject(err); &#125; else &#123; extractUrls(body).then( urls =&gt; resolve(urls), err =&gt; reject(err) ); &#125; &#125;); &#125;);&#125;function extractUrls(body) &#123; return new Promise((resolve, reject) =&gt; &#123; parseString(body, (err, result) =&gt; &#123; if (err) &#123; console.error(`解析sitemap时遇到问题：$&#123;err.message&#125;`); reject(err); &#125; else &#123; let urls = result.urlset.url.map((url) =&gt; &#123; return url.loc[0]; &#125;); console.log(`从sitemap中提取$&#123;urls.length&#125;个url：\n$&#123;urls.join('\n')&#125;`); resolve(urls); &#125; &#125;); &#125;)&#125;]]></content>
      <categories>
        <category>技术</category>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>SEO</tag>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThinkJS 3.0]]></title>
    <url>%2F2017%2F08%2Flearn-thinkjs%2F</url>
    <content type="text"><![CDATA[概述ThinkJS 是一款面向未来开发的 Node.js 框架，底层基于 Koa 2.x 实现，内核小巧、性能优异，内置自动编译、自动更新机制，使用更优雅的 async/await 处理异步问题，兼容中间件并提供了扩展和适配器等插件方式。针对企业级应用开发，使开发变得更加简单、高效。 个人见解这一节内容是我在学习完 ThinkJS 基本用法后加上的，主要谈谈关于 ThinkJS 的一些个人见解。 这里不得不引用官方文档中的架构图。 从架构图我们可以清晰的看到 ThinkJS 底层是基于 Koa 2.x，主要分为中间件、扩展和适配器三个核心模块。其中中间件主要用来处理用户的请求，当用户向服务器发出请求时，顺序执行中间件，最终返回用户期望的结果。扩展和适配器往往搭配使用，提供一些诸如：Session、模板引擎、数据库模型等扩展功能。 在我看来，ThinkJS 其实就是对一个应用如何构建进行了划分，将一个应用分成了各个模块（中间件、扩展），各个模块各司其职，处理自己的逻辑。我们只需要将相应的逻辑写在相应的地方，然后进行相应的一些配置。在应用启动时，ThinkJS 根据配置文件装载相应的模块，当用户请求到达时，按照配置将处理权交给相应的模块，完成请求的响应。整个应用都是可配置的，大大增强了灵活性。 ThinkJS 的工作模式按照官方文档上的说法主要分为两个部分，一个是系统服务启动，另一个是用户请求处理。这一点我感觉没有什么特殊的地方，我觉得所有的后台应用都是这两个部分，都是需要启动服务监听端口，然后等待客户端的请求到来，处理请求并响应。只不过在这两个阶段进行的具体工作有些许差异罢了。ThinkJS 在系统服务启动阶段，除了启动服务监听端口外，最主要的工作就是装配。按照 ThinkJS 的架构，我们需要什么功能或者需要执行什么操作，只需要将相应的代码写在相应的地方，然后添加响应的配置。为什么我们这样做了就可以实现我们需要的功能？必然是 ThinkJS 在启动时进行了装配。 我们以在 ThinkJS 中添加模板页面功能为例，来梳理一下 ThinkJS 扩展和适配器机制以及系统服务启动。扩展功能在我理解就是在相应的环境（全局、上下文或者控制器）下添加了一个对象，我们可以直接使用它提供的一些方法，来实现相应的功能。按照 ThinkJS 的架构，我们需要先实现这个对象（扩展）或者直接使用别人的，这个对象至少有一个 render 方法，能将模板文件渲染成 html 文件。然后，在配置文件 src/config/extend.js 中我们需要引入这个对象并添加这个对象的配置。接着，我们还需要在适配器中添加一个具体的模板引擎配置。完成这几步后，我们就可以直接在控制器中通过 this.render() 渲染模板页面了。那么为什么经过这样的几个步骤后，就可以使用模板页面了呢？我们可以在控制器中直接使用 this.render()，肯定是 ThinkJS 在控制器对象上添加了这个方法，添加这个方法的依据应该就是我们在扩展配置文件中添加了 view 配置，而我们执行这个方法具体的实现则是根据适配器中的配置来的。扩展相当于定义了一个功能接口，而适配器中进行具体的实现。服务启动后，读取扩展配置，装配相应的对象（扩展功能）。在具体使用该功能时，根据适配器中的配置，不同的类型有不同的实现。 后台应用的核心主要还是处理用户请求，处理用户请求主要通过各种中间件来完成。通过中间件，将处理请求的流程截取成了多个部分，各个中间件完成各自的功能，整个处理过程类似于一个流水线生产。扩展也是为这一过程服务的，定义的扩展功能可以在请求处理的过程中调用，去完成更加具体的工作。我觉得扩展是作为中间件的一部分存在的，去实现中间件中的某一个具体功能。请求处理流程大致如下图所示。 各种中间件分别对 request 进行加工，然后由路由分配给指定的控制器去处理，在控制器处理之前 ThinkJS 中会先经过一个叫做 Logic 的中间件，对数据进行验证、过滤。控制器在处理请求时，可以随时调用扩展功能去实现某个具体的操作，接口都是统一的，由适配器去完成各种不同的实现。最后，将响应结果返回给客户端。 那么，使用 ThinkJS 能带来什么好处呢？首先，应用如何启动我们不需要花费太多的精力，通过配置文件以及 worker 即可完成。其次，对于请求处理，通过中间件、扩展和适配器以及相应的配置，我们可以很快速的添加相应的处理逻辑。同时，还可以保证一个良好的代码结构。最后，ThinkJS 提供了很多通用的机制，去解决一些通用问题，例如：日志、数据模型、Cookie、错误处理等。 总之，就目前的了解来看，ThinkJS 最优秀的地方在于它很简单，可以快速的上手。只要按照它的架构，就能很轻松的构建出整个应用。框架本身并不算复杂，但通过一些内部机制又可以增添很多丰富的功能。内置的一些功能模块也解决的了很多通用的问题。更具体的优缺点还得待具体使用后才知道。 开始使用ThinkJS提供了脚手架工具，可以帮助我们快速创建一个项目，要求 Node.js 的版本大于 6.x。 12$ npm install -g think-cli$ thinkjs new &lt;project-name&gt; 执行完上述命令后，就可以创建出一个项目骨架。进入该项目，安装依赖后可直接启动。 123$ cd &lt;project-name&gt;$ npm install$ npm start 启动后，访问 http://127.0.0.1:8360 可以看到初始化页面。 通过脚手架构建的项目目录结构如下： 1234567891011121314151617181920212223242526272829303132.|--- development.js //开发环境下的入口文件|--- nginx.conf //nginx 配置文件|--- package.json|--- pm2.json //pm2 配置文件|--- production.js //生产环境下的入口文件|--- README.md|--- src| |--- bootstrap //启动自动执行目录| | |--- master.js //Master 进程下自动执行| | |--- worker.js //Worker 进程下自动执行| |--- config //配置文件目录| | |--- adapter.js // adapter 配置文件| | |--- config.js // 默认配置文件| | |--- config.production.js //生产环境下的默认配置文件，和 config.js 合并| | |--- extend.js //extend 配置文件| | |--- middleware.js //middleware 配置文件| | |--- router.js //自定义路由配置文件| |--- controller //控制器目录| | |--- base.js| | |--- index.js| |--- logic //logic 目录| | |--- index.js| |--- model //模型目录| | |--- index.js|--- view //模板目录| |--- index_index.html|--- www| |--- static //静态资源目录| | |--- css| | |--- img| | |--- js 基本用法关于ThinkJS的基本用法主要是参考了官方文档的内容，根据文档说明依次尝试了相应的模块并记录下核心的内容。 配置所有的配置文件都放在 src/config/ 目录下，根据不同的功能划分为不同的配置文件。其中，通用配置和适配器配置支持在不同的环境下配置不同的值，只需要将配置文件命令为 [name].[env].js 这种形式即可。例如：config.production.js 表明这是生产环境中的配置，该文件中的 key 会覆盖 config.js 中同名的 key。运行环境在实例化 Application 对象时通过 env 参数指定，如下所示。 12345const instance = new Application(&#123; ROOT_PATH: __dirname, proxy: true, // use proxy env: 'production'&#125;); 在程序运行时可以获取和动态设置配置，获取配置可以通过上下文、controller 和全局的 think 对象，动态设置只能通过 think。下面是获取和设置配置的例子。 123456// HTTP 服务启动前执行think.beforeStartServer(async () =&gt; &#123; console.log(`全局环境下读取端口号配置: $&#123;think.config('port')&#125;`); console.log('动态配置端口号为: 8088'); think.config('port', '8088'); // 动态配置端口号。&#125;); 通过 DEBUG=think-loader-config-* npm start 命令来启动项目可以在控制台查看配置文件的详细加载情况。 上下文 Context 是 Koa 中处理用户请求中的一个对象，贯穿整个请求生命周期。一般在 middleware、controller、logic 中使用，简称为 ctx。 Context 中包含了许多信息以及一些便捷操作，下面列举部分，详情见 ThinkJS 文档 可以通过上下文获取 request 和 response 对象。 可以过ctx.state在中间件中传递信息，而不是直接添加到 ctx 上。 ctx.throw 抛出包含 .status 属性的异常，默认状态码为 500。 ctx.json 输出 JSON 格式数据。 ctx.success 和 ctx.fail 输出成功和失败数据。 ctx.confg 读取配置。 中间件ThinkJS 中通过统一的配置文件来管理中间件，配置文件为 src/config/middleware.js。中间件分为框架内置中间件和项目自定义中间件两种。内置的中间件可以通过字符串的方式直接引用，内置中间件有下面这些： meta 显示一些 meta 信息，如：发送 ThinkJS 的版本号，接口的处理时间等等。 resource 处理静态资源，生产环境建议关闭，直接用 webserver 处理即可。 trace 处理报错，开发环境将详细的报错信息显示处理，也可以自定义显示错误页面。 payload 处理表单提交和文件上传，类似于 koa-bodyparser 等 middleware。 router 路由解析，包含自定义路由解析。 logic logic 调用，数据校验。 controller controller 和 action 调用。 项目自定义的中间件定义在 src/middleware 目录下，然后也可以通过字符串的方式引用。下面是一个计算当前请求执行时间的中间件的例子。 首先在 src/middleware 目录下新建一个 compute-request-time.js 的文件，文件中写下如下代码： 12345678910111213141516171819202122const defaultOptions = &#123; consoleExecTime: false // 是否打印执行时间的配置&#125;module.exports = (options = &#123;&#125;) =&gt; &#123; // 合并传递进来的配置 options = Object.assign(&#123;&#125;, defaultOptions, options); return (ctx, next) =&gt; &#123; if (!options.consoleExecTime) &#123; return next(); // 如果不需要打印执行时间，直接调用后续执行逻辑 &#125; const startTime = Date.now(); let err = null; // 调用 next 统计后续执行逻辑的所有时间 return next().catch(e =&gt; &#123; err = e; // 这里先将错误保存在一个错误对象上，方便统计出错情况下的执行时间 &#125;).then(() =&gt; &#123; const endTime = Date.now(); console.log(`request exec time: $&#123;endTime - startTime&#125;ms`); if (err) return Promise.reject(err); // 如果后续执行逻辑有错误，则将错误返回 &#125;) &#125;&#125; 接着在配置文件 src/config/middleware.js 中增加如下配置： 12345678module.exports = [&#123; handle: 'compute-request-time', enable: think.env === 'development', // 这个中间件只在开发环境下生效 options: &#123; consoleExecTime: true &#125;, match: '/' // 请求的 URL 是 / 打头时这个中间件才启用&#125;]; 参数及含义如下： handle 中间件的处理函数。 enable 是否启用中间件。 options 传递给中间件的参数，是一个对象，可以通过函数返回。 match 匹配特定的规则后才执行该中间件，支持二种方式，一种是路径匹配，一种是自定义函数匹配。 注意： 如果中间件没有定义在 src/middleware/ 目录下，在配置文件中配置时需要引入。 中间件的执行顺序是配置文件中的顺序。 LogicLogic 层在 Controller 之前执行，主要是完成一些过滤、数据校验、权限判断等一些逻辑性不是特别强但又和业务逻辑相关的工作，降低 Action 中代码的复杂程度。Logic 里的 Action 和控制器里的 Action 一一对应，系统在调用控制器里的 Action 之前会自动调用 Logic 里的 Action。 Logic 代码类似如下： 1234567891011module.exports = class extends think.Logic &#123; __before() &#123; // todo &#125; indexAction() &#123; // todo &#125; __after() &#123; // todo &#125;&#125; 要点： Logic 和 Controller 的文件名应该相同。 Logic 中进行数据校验时，会根据请求类型自动获取，也可以手动获取设置到数据的 value 属性上。 控制器控制器负责处理用户请求的逻辑，每一个操作对应一个 Action。Controller 代码类似如下： 123456789101112131415161718192021222324const Base = require('./base.js');module.exports = class extends Base &#123; __before() &#123; console.log('Before user action.'); &#125; indexAction() &#123; this.body = 'hello world!'; &#125; profileAction() &#123; this.body = 'User profile!'; &#125; __call() &#123; //如果相应的Action不存在则调用改方法 this.body = 'Not Found'; &#125; __after() &#123; console.log('After user action.'); &#125;&#125;; 访问 /user 或 /user/index 会执行 indexAction；访问 /user/profile 会执行 profileAction。 在 controller 目录下创建子目录并添加 controller 可以进行多级匹配。例如：在 controller 目录下创建一个 user 目录并添加一个名为 login.js 的控制器，当访问 /user/login 时，会执行 login.js 中的 indexAction。 Controller 里的处理顺序依次为 __before、xxxAction、__after，return false 可以提前结束请求。 ViewThinkJS 3.0 没有内置 View 功能，需要通过 Extend 和 Adapter 中的配置来实现，具体如何配置参考官网文档。 配置了 Extend 和 Adapter 后，就可以在 Controller 里使用了： 12345678910module.exports = class extends think.Controller &#123; indexAction()&#123; this.assign('title', 'thinkjs'); //给模板赋值 /* * 渲染模板，实际上调用了 this.reader() 方法获取渲染后的内容，然后将内容赋值到 ctx.body上。 */ return this.display(); &#125;&#125; 在模板中可以使用 assign 方法添加的变量。同时，系统在渲染模板的时候，自动注入 controller、config、ctx 变量，以便于在模板里直接使用。 路由上面说到当访问 /user/profile 时，会执行 user 控制器中的 profileAction，这一过程由路由来完成。ThinkJS 使用 think-router 中间件。 当 Controller 有子目录时，会优先匹配子 Controller，然后才匹配 action。 支持在 src/config/router.js 中配置自定义路由规则，路由规则为一个二维数组，如下所示： 1234module.exports = [ [/libs\/(.*)/i, '/libs/:1', 'get'], [/fonts\/(.*)/i, '/fonts/:1', 'get,post'],]; 每一条路由规则也为一个数组，数组里面的项分别对应为：match、pathname、method、options： match {String | RegExp} pathname 匹配规则，可以是字符串或者正则。如果是字符串，那么会通过 path-to-regexp 模块转为正则。 pathname {String} 匹配后映射后的 pathname，后续会根据这个映射的 pathname 解析出对应的 controller、action。 method {String} 该条路由规则支持的请求类型，默认为所有。多个请求类型中间用逗号隔开，如：get,post。 options {Object} 额外的选项，如：跳转时指定 statusCode。 适配器Adapter 是一类功能的不同实现，这些实现提供一套相同的接口，例如：多种数据库、模板引擎。Adapter 一般是不能独立使用的，而是配合对应的扩展一起使用。 Adapter 可以根据不同的运行环境设置不同的配置，例如：创建 adapter.production.js 文件指定生产环境下的适配器配置。 除了引入外部的 Adapter 外，项目内也可以创建 Adapter 来使用。Adapter 文件放在 src/adapter/ 目录下（多模块项目放在 src/common/adapter/），如：src/adapter/cache/xcache.js，表示加了一个名为 xcache 的 cache Adapter 类型，然后该文件实现 cache 类型一样的接口即可。 扩展扩展在 src/config/extend.js 文件中配置，格式为数组，如下所示： 12345const view = require('think-view');module.exports = [ view //make application support view]; 支持自定义扩展，文件放在 src/extend/ 目录下，下面是给 ctx 添加判断当前请求是不是手机访问的扩展的例子。 首先在 src/extend 目录下新建一个 context.js 的文件，文件中写下如下代码： 1234567module.exports = &#123; get isMobile() &#123; const userAgent = this.userAgent.toLowerCase(); const mList = ['iphone', 'android']; return mList.some(item =&gt; userAgent.indexOf(item) &gt; -1); &#125;&#125; 这样就可以通过 ctx.isMobile 来判断是否是手机访问了。 异步/错误处理这一部分主要利用了 ES2017 标准中引入的 async 函数。基本的用法与 async 函数的用法相同，没有太多的封装。 由于 Node.js 原生的异步方法都是 callback 方式，为了方便的将 callback 接口封装为 Promise 接口，ThinkJS 提供了 think.promisify 用来快速的封装，如： 1234567const fs = require('fs');const readFile = think.promisify(fs.readFile, fs);const parseFile = async (filepath) =&gt; &#123; const content = await readFile(filepath, 'utf8'); // readFile 返回 Promise doSomethingWithContent();&#125; 但是，这个方法只能封装 callback(err, data) 形式的回调函数，否则只能手动封装。 错误处理除了 try/catch 和 then/catch 之外，还提供了一个 trace 中间件来统一处理运行时的异常。 模型/数据库ThinkJS 默认没有提供模型功能，而是通过扩展的方式实现，对应的模块为 think-model。在 src/config/extend.js中添加如下配置即可： 12345const model = require('think-model');module.exports = [ model(think.app) // 让框架支持模型的功能] 添加了模型扩展后，就可以通过 think.model、ctx.model、controller.model等进行使用。 模型可以支持多种数据库，在 scr/config/adapter.js 中配置即可。如下所示： 1234567891011121314151617181920212223const mysql = require('think-model-mysql');exports.model = &#123; type: 'mysql', // 默认使用的类型，调用时可以指定参数切换 common: &#123; // 通用配置 logConnect: isDev, // 是否打印数据库连接信息 logSql: isDev, // 是否打印 SQL 语句 logger: msg =&gt; think.logger.info(msg) // 打印信息的 logger &#125;, mysql: &#123; // mysql 配置 handle: mysql, database: '', prefix: 'think_', encoding: 'utf8', host: '127.0.0.1', port: '', user: 'root', password: 'root', dateStrings: true &#125;, sqlite: &#123; // sqlite 配置 &#125;,&#125;; 在适配器中添加相关配置后，在使用模型时指定相应的类型即可。例如使用 sqlite 的配置：const user = think.model(&#39;user&#39;, &#39;sqlite&#39;); 模型文件创建在 src/model 目录下，继承模型基类 think.Model，model 代码类似如下： 123456// src/model/user.jsmodule.exports = class extends think.Model &#123; getList() &#123; return this.field('name').select(); &#125;&#125; 定义了模型后，通过 const usreModel = think.model(&#39;user&#39;, &#39;sqlite&#39;) 获取模型实例，然后就可以调用模型提供的方法 usreModel.getList()。 think.Model 基类提供了丰富的方法进行 CRUD 操作，我们可以对这些方法进行封装，例如上面的例子。具体有哪些方法详见官网文档。 think-model 扩展主要用来支持关系型数据库，还提供了 think-mongo 扩展来支持 MongoDB，添加如下扩展即可。 12345const mongo = require('think-mongo');module.exports = [ mongo(think.app) // 让框架支持模型的功能] 添加扩展后，可以通过 think.mongo、ctx.mongo 等方法使用。 MondoDB 数据库适配器的配置复用了关系型数据的配置。模型的定义和关系型数据库类似，只是继承的是 think.mongo。官方API]]></content>
      <categories>
        <category>技术</category>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>ThinkJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用软件安装]]></title>
    <url>%2F2017%2F08%2Fsoftware-install%2F</url>
    <content type="text"><![CDATA[有些软件的源不太好，有的也还需要破解。这里记录下一些安装时可能需要找一会在哪里下载或者需要破解的软件，便于以后重装时可以快速找到相应的资源。内容不间断更新。 Office 2016 for macOS资源下载 Office 2016 for macOS 破解程序，百度网盘下载 安装及激活Office 直接安装即可。安装完成后，打开破解程序，打开时会显示已激活状态，但是此时其实并没有激活。点击中间的钥匙图标即可完成激活。 WebStorm资源下载直接在官网下载最新版 WebStorm 即可。 安装及激活下载完成后直接安装，安装成功后打开程序，在程序激活页面选择 Server License，填入下面的地址即可激活。 http://idea.imsxm.com/ Navicat PremiumNavicat Premium 是一套相当好用的数据库开发工具，使用这一个程序就可以连接多种常见数据库。但是，软件本身是需要收费的并且价格不便宜。 当时在安装破解版的时候花了很多时间，网上的资源好多都不能用，最后终于找到了一个破解版，下载安装后即可使用。 链接: http://pan.baidu.com/s/1eRG9LPS 密码:f5cc]]></content>
      <categories>
        <category>收藏</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Express 4.0]]></title>
    <url>%2F2017%2F08%2Flearn-express%2F</url>
    <content type="text"><![CDATA[概述Express 是一个基于 Node.js 平台的极简、灵活的 web 应用开发框架，它提供一系列强大的特性，帮助你创建各种 Web 和移动设备应用。Express 具有丰富的 HTTP 快捷方法和任意排列组合的 Connect 中间件，让你创建健壮、友好的 API 变得既快速又简单。同时，Express 不对 Node.js 已有的特性进行二次抽象，我们只是在它之上扩展了 Web 应用所需的基本功能，因此不会出现由于过多的抽象和包装导致的性能损耗问题。 开始使用Express 上手非常的简单，使用 Express 需要 Node.js，这里假定已经安装好了 Node.js，我们直接开始写一个 Hello World。 Hello World首先新建一个项目目录并进行一些初始化操作。 123$ mkdir hello-world$ cd hello-world$ npm init 执行完上述操作后，hello-world 目录下会生成一个 package.json 文件，包含一些项目相关信息。 接下来直接通过 npm 安装 Express 就可以了。 1$ npm install express 执行完上面的命令后，在项目的根目录下新建一个 app.js 文件，然后将下面的代码复制进去： 12345678910111213var express = require('express');var app = express();app.get('/', function(req, res)&#123; res.send('&lt;h1&gt;Hello World!&lt;/h1&gt;');&#125;);var server = app.listen(8080, function()&#123; var host = server.address().address; var port = server.address().port; console.log('Example app listening at http://%s:%s', host, port);&#125;); 上面的代码启动一个服务并监听从 8080 端口进入的所有连接请求，他将对所有 (/) URL 或 路由 返回 “Hello World!” 字符串。对于其他所有路径全部返回 404 Not Found。 我们可以通过下面的命令启动应用，然后通过浏览器访问http://localhost:8080，网页上会显示一个 Hello World。1$ node app.js 脚手架我们可以通过脚手架工具快速创建一个 Express 应用。通过下面的命令全局安装脚手架工具。 1$ npm install express-generator -g 安装完成后，我们可以通过下面命令创建一个名为 my-first-app 的应用。 1$ express my-first-app -e -e 参数表明使用的 ejs 作为模板引擎，默认使用的 jade。我们可以通过 express -h 查看支持的参数。 应用创建完成后，我们需要进入到该目录下安装所有的依赖。 12$ cd my-first-app$ npm install 然后就可以启动应用了，设置 DEBUG 环境变量为当前应用名称可以以调试模式启动应用。 1$ DEBUG=my-first-app npm start 注意：上面的命令是 masOS 或者 Linux 平台，如果是 Windows 平台，需要使用下面的命令。 1$ set DEBUG=my-first-app &amp; npm start 应用启动后，在浏览器中打开 http://localhost:3000/ 网址就可以看到这个应用了。 通过 Express 应用生成器创建的应用一般都有如下目录结构： 12345678910111213141516171819.├── app.js├── bin│ └── www├── package.json├── public│ ├── images│ ├── javascripts│ └── stylesheets│ └── style.css├── routes│ ├── index.js│ └── users.js└── views ├── error.jade ├── index.jade └── layout.jade7 directories, 9 files 内部原理Express 框架的核心是对 Node.js 内置 http 模块的一个封装。原生 http 模块启动一个服务的代码如下： 12345var http = require('http');var server = http.createServer(function(request, response) &#123; // Handle request.&#125;);server.listen(8080); 上面代码的关键部分是 http 模块的 createServer 方法，该方法接受一个回调函数，当有客户端的请求抵达服务器时，会触发该函数。该回调函数有两个参数，分别对应 request 和 response 对象。 Express 其实就是对 http 模块的一个封装，上面的代码使用 Express 改写如下： 1234567var http = require('http');var express = require('express');var app = express();var server = http.createServer(app);server.listen(8080); 通过上述代码不难看出，express 拦截了 http 请求，当请求到达时，交由 app 进行处理。那么，这个 “app” 是什么呢?app 其实就是一个 Function，并且接受 request 和 response 对象以及一个叫做 next 的参数。源码如下： 123456789101112131415161718192021function createApplication() &#123; var app = function(req, res, next) &#123; app.handle(req, res, next); &#125;; mixin(app, EventEmitter.prototype, false); mixin(app, proto, false); // expose the prototype that will get set on requests app.request = Object.create(req, &#123; app: &#123; configurable: true, enumerable: true, writable: true, value: app &#125; &#125;) // expose the prototype that will get set on responses app.response = Object.create(res, &#123; app: &#123; configurable: true, enumerable: true, writable: true, value: app &#125; &#125;) app.init(); return app;&#125; 当服务器收到客户端的请求时，调用 app 方法，在 app 方法内部会执行 app.handle 那么 app.handle 中会做些什么呢？还是继续看源码： 123456789101112131415161718app.handle = function handle(req, res, callback) &#123; var router = this._router; // final handler var done = callback || finalhandler(req, res, &#123; env: this.get('env'), onerror: logerror.bind(this) &#125;); // no routes if (!router) &#123; debug('no routes defined on app'); done(); return; &#125; router.handle(req, res, done);&#125;; 从上面的代码可以看出 app.handle 会将处理交由 router 进行处理，如果 router 不存在，则执行回调函数或者 handler。其中 router 就是路由容器，负责分发请求，依次执行相应的处理函数。 看到这里就能大致推测出 Express 的内部工作机制了：Express 将 app 方法绑定为 http 请求的处理函数，当请求到达时触发该方法。在该方法的内部，由路由容器对请求进行分发，交由相应的处理函数处理，而处理函数显然需要提前进行注册并且是被顺序调用的。这里的“处理函数“在 Express 中被成为中间件。 中间件中间件说白了就像是流水线上一个工人，对产品（http 请求）进行某项特定的加工。它最大的特点就是顺序执行，Express 运行的过程其实就是顺序调用一系列的中间件。 每个中间件都会从 Express 实例对象中获取到三个参数：request 对象、response 对象和 next 对象，分别对应 http 请求、http 响应以及 负责调用下一个中间件的 next 方法。 Express 通过 use 方法注册中间件，该方法返回一个函数。下面是一个简单的示例： 1234567891011121314var express = require('express');var app = express();app.use(function(req, res, next) &#123; console.log(req.method + ':' + request.url); next();&#125;);app.user(function(req, res, next) &#123; res.end('&lt;h1&gt;Hello World!&lt;/h1');&#125;);app.listen(8080); 上面的代码使用了 app.use 方法注册了两个中间件，在收到 http 请求后会顺序调用这两个方法。首先在控制台输出一行信息，然后调用 next 方法，执行下一个方法，响应 http 请求。 use 方法内部可以对访问路径进行判断，据此就能实现简单的路由，根据相应的请求路径，返回相应的请求结果。例如： 12345678910111213var express = require('express');var app = express();app.user(function(req, res, next) &#123; if (req.url === '/') &#123; res.end('&lt;h1&gt;Hello World!&lt;/h1'); &#125; else &#123; res.status(404).end(); &#125;&#125;);app.listen(8080); 上面的代码通过 request.url 属性，判断请求的网址，返回不同的内容。 路由路由定义了匹配某个url的处理函数，由一个 url、http 请求（GET、POST等）和若干个处理函数组成，下面是一个基本的路由： 123456var express = require('express');var app = express();app.get('/', function(req, res) &#123; res.send('hello world');&#125;); 路由方法路由方法来源于 http 请求，如：get、post、put等。其中 app.all() 是一个特殊的路由方法，没有任何 http 方法与其对应，它的作用是对于一个路径上的所有请求加载中间件。下面是一些路由的实例： 123456789101112app.get('/', function (req, res) &#123; res.send('GET request to the homepage');&#125;);app.post('/', function (req, res) &#123; res.send('POST request to the homepage');&#125;);app.all('/secret', function (req, res, next) &#123; console.log('Accessing the secret section ...'); next(); // pass control to the next handler&#125;); 路由路径路由路径匹配 htpp 请求的路径，可以是字符串、字符串模式或者是正则表达式。下面是一些路由路径的示例： 1234567891011121314// 匹配根路径的请求app.get('/', function (req, res) &#123; res.send('root');&#125;);// 匹配 acd 和 abcdapp.get('/ab?cd', function(req, res) &#123; res.send('ab?cd');&#125;);// 匹配 butterfly、dragonfly，不匹配 butterflyman、dragonfly man等app.get(/.*fly$/, function(req, res) &#123; res.send('/.*fly$/');&#125;); 路由句柄可以为一个请求提供多个处理函数，其行为类似中间件。路由句柄有多种形式，可以是一个函数、一个函数数组，或者是两者混合。如下所示： 12345678910111213141516var fun1 = function (req, res, next) &#123; console.log('fun1'); next();&#125;var fun2 = function (req, res, next) &#123; console.log('fun2'); next();&#125;app.get('/example/d', [fun1, fun2], function (req, res, next) &#123; console.log('response will be sent by the next function ...'); next();&#125;, function (req, res) &#123; res.send('Hello from D!');&#125;); 使用 app.route() 可以创建链式的路由句柄。由于路径在一个地方指定，这样做有助于创建模块化的路由，而且减少了代码冗余和拼写错误。下面是一个简单的示例： 12345678910app.route('/user') .get(function(req, res) &#123; res.send('Get a random book'); &#125;) .post(function(req, res) &#123; res.send('Add a book'); &#125;) .put(function(req, res) &#123; res.send('Update the book'); &#125;); 路由中间件Express.Router 是一个构造函数，用来创建一个模块化、可挂载的路由句柄，它好像小型的 Express 应用程序一样，有自己的 use、get、param 和 route 方法。下面是一个路由中间件的基本例子。 在项目目录下新建一个 login.js 文件，文件的内容如下： 1234567891011121314var express = require('express');var router = express.Router();// 该路由使用的中间件router.use(function timeLog(req, res, next) &#123; console.log('Time: ', Date.now()); next();&#125;);router.post('/', function(req, res) &#123; // Login...&#125;);module.exports = router; 然后在 app.js 中加载路由模块： 123var login = require('./login');app.user('/login', login); 这样应用就可以处理发到 /login 上的请求，并且调用为该路由指定的 timeLog 中间件。 模板引擎在 Express 中使用模板引擎，需要在应用中进行如下设置才能让 Express 渲染模板引擎： 12345678910var express = require('express');var path = require('path');var app = express();// 设置模板文件目录app.set('views', path.join(__dirname, 'views'));// 设置模板引擎app.set('view engine', 'jade'); 模板引擎设置完成后，在 views 目录下创建一个名为 index.ejs 的文件，内容如下： 12345html head title!= title body h1!= message 然后创建一个路由渲染 index.jade 文件。如果没有设置 view engine，您需要指明视图文件的后缀，否则就会遗漏它。 123app.get('/', function (req, res) &#123; res.render('index', &#123; title: 'Hey', message: 'Hello there!'&#125;);&#125;); 完成上述操作后，访问主页就可以看到 index.jade 被渲染为 HTML。 常用对象及其属性和方法Express静态方法Express.static(root[, options]) &emsp;&emsp;托管 Express 应用内的静态资源。root 参数指的是静态资源文件所在的根目录；options 可选的参数对象，包含一些缓存相关的字段：etag、lastModified、maxAge，以及一个设置 HTTP 相应头的函数等。 实例方法app.listen(port[, hostname][, backlog][, callback]) &emsp;&emsp;监听指定的主机和端口号 app.use([path, ]function[, function…]) &emsp;&emsp;将中间件挂载到指定的路径，默认是根路径 app.all(path, callback[, callback…]) &emsp;&emsp;匹配所有的请求方法 app.get(path, callback[, callback…]) &emsp;&emsp;匹配浏览器get请求 app.post(path, callback[, callback…]) &emsp;&emsp;匹配浏览器post请求 app.render(view[, locals][, callback]) &emsp;&emsp;通过回调函数渲染模板页面 app.route(path) &emsp;&emsp;创建链式的路由句柄 Request实例属性req.app &emsp;&emsp;Express app 实例 req.baseUrl &emsp;&emsp;路由的挂载的路径 req.body &emsp;&emsp;请求体 req.cookies &emsp;&emsp;cookies req.query &emsp;&emsp;get请求参数对象 实例方法req.get(field) &emsp;&emsp;获取 Http 请求头参数 req.param(name[, defualtValue]) &emsp;&emsp;读取请求的参数，会从url和body中查找 Response实例属性res.app &emsp;&emsp;Express app 实例 res.locals &emsp;&emsp;本次请求中的本地变量，不同于app.locals。 实例方法res.send([body]) &emsp;&emsp;返回 Http 响应 res.sendStatus(statusCode) &emsp;&emsp;返回状态吗 res.json([body]) &emsp;&emsp;返回JSON数据 res.append(field[, value]) &emsp;&emsp;向 Http 响应头中添加变量 res.render(view [, locals] [, callback]) &emsp;&emsp;渲染并返回模板页面 res.cookie(name, value[, options]) &emsp;&emsp;设置cookie res.end([data][, encoding]) &emsp;&emsp;结束相应 res.redirect([status, ]path) &emsp;&emsp;重定向 总结这几天对 Express 的学习和运用，给我最大的感觉就是 Express 的极简和灵活以及那种流水线的工作模式，它完全就是一个由路由和中间件构成的 Web 框架。基于 Express 可以很快速的构建项目，各种功能按需添加，即插即用。结构十分清晰，各个模块之间解耦、职责分明。不过，也正是因为 Express 的灵活，如果在使用的过程中没有清晰的思路和好的规划，仍然会导致代码杂乱无章，这里插一点东西，那里插一点东西。 对于 Express 我感觉用来构建一个循序渐进的项目是最适合不过了，开始的时候只需要少量的工作就可以让项目跑起来。接着，在后续的开发过程中，可以通过路由和中间件不断的添加新的功能，逐步的完成整个项目的定制。而且，还可以对 Express 进行一些基本的封装，把一些较为通用的功能预先集成进去，然后在此基础上进行各类项目的定制。 总而言之，Express 可以很快速的构建小型项目，也可以完成大型项目的深度定制，可谓是文武双全，适应性及其广泛。只是，这样的灵活性也意味着功能较为简单，仍然有一些较为通用的处理需要去做，对于企业级开发，也许抽象层次更高，功能更加丰富的框架更为适合。]]></content>
      <categories>
        <category>技术</category>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客中使用Chrome主题中的背景图片]]></title>
    <url>%2F2017%2F08%2Fuse-chrome-theme-background%2F</url>
    <content type="text"><![CDATA[今天打开Chrome，看到首页上那炫酷的主题背景，突然想到我博客好像还没有背景，这着实让人觉得不开心。于是，趁着中午休息的时间，我决定给博客也添加一个背景。 顺手牵羊既然要背景，那当然得有个好看的图片素材。既然我是看到Chrome的主题背景才萌生这个想法的，那素材也同样从Chrome的主题背景中取好了。恰好最近十分中意应用商店中一个叫做Flying Paint的主题背景，于是就决定用这个主题图片作为博客的背景。 直接在主页右键--&gt;检查（或者其他诸如快捷键打开开发者工具之类的），然后定位到body元素查看它的样式。在右侧的样式面板中，可以看到body上添加了一个背景样式，直接复制样式中的图片url并在新的标签页中打开就能看到背景图片了。 这里需要注意的是，body的背景图片使用了CSS中一个叫做image-set的属性，该属性可以根据用户设备的分辨率匹配合适的图像，目前并不被所有浏览器支持。所以，我建议直接使用1x图片，因为我试过大号的图片，在我的设备（13.3英寸的mac和1920*1080的显示器）上显示出来并不好看。直接在图片上右键，选择图片存储为...即可保存到本地。 南蛮入侵借来了图片之后，就需要把图片添加到博客中。我的博客基于Hexo构建，使用的NexT主题。直接将保存下来的图片复制到themes/next/source/images目录下，然后打开theme/next/source/css/_custom/_custom.styl文件，在文件中中添加下面的样式即可。 123body &#123; background: url(/images/&lt;IMAGE_NAME&gt;) center no-repeat fixed rgb(255, 255, 255);&#125; 完成了上述的步骤后，我的博客就也有了炫酷的背景了。开心…😃]]></content>
      <categories>
        <category>航海日志</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>CSS</tag>
        <tag>Chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在WebStorm中使用Git Submodule]]></title>
    <url>%2F2017%2F08%2Fgit-submodule-webstorm%2F</url>
    <content type="text"><![CDATA[有时候我们需要在一个项目中使用另一个项目，即当前的父项目下包含一个子项目。我们可能会对子项目中的内容进行修改，并且希望父项目和子项目中的修改可以分别提交。Git通过子模块来实现这个需求，子模块允许将一个Git仓库作为另一个Git仓库的子目录。它能让我们将另一个仓库克隆到自己的项目中，同时还保持提交的独立。接下来，介绍下如何在WebStorm中使用子模块。 开始使用 首先可以通过终端命令添加子模块到指定目录下，不能提前创建好该目录，否则会报错。 1$ git submodule add &lt;repo&gt; &lt;directory&gt; 添加完子模块之后，在当前目录下会生成一个.gitmodules的文件，该置文件保存了项目URL与已经拉取的本地目录之间的映射，这个文件也应该提交到Git中。此时如果执行git status命令或者在WebStorm的Version Control &gt; Local Changes标签页下可以看到有一个未提交的修改，对应的是Clone的子模块文件夹。当不在那个目录中时，Git并不会跟踪它的内容，而是将它看作该仓库中的一个特殊提交。 123[submodule &quot;public/home-assistant-polymer&quot;] path = public/home-assistant-polymer url = git@github.com:hezhii/home-assistant-polymer.git 上面说到，Git并不会跟踪子仓库中的内容，而是视为一个子模块。但是，通过WebStorm我们可以看到子模块中的具体修改内容，就像是一个文件夹一样。在WebStorm的设置中，选择Version Control，我们可以看到克隆的子模块，只需要选中它并点击下方的+就可以注册该模块，这样子模块中的内容变化也会显示在Local Changes中。 在后续的开发中，无论是父模块还是子模块中的内容发生了修改，都可以直接提交，WebStorm会帮我们将修改提交到对应的仓库中。 克隆含有子模块的项目当我们在克隆一个包含子模块的项目是，默认会包含该子模块目录，但其中还没有任何文件。我们必须执行下面两个命令： git submodule init用来初始化本地配置文件。 git submodule update从子模块中获取所有数据并检出父项目中列出的提交。 或者可以在执行git clone命令时指定--recursive参数，这样就会自动初始化并更新仓库中的每一个子模块。 删除子模块 编辑.gitmodules和.git/config文件，删除子模块相关配置。 执行git rm --cached path_to_submodule命令，清除子模块缓存。 删除子模块文件夹及相关文件。 提交修改。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>WebStorm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决博客搭建在GitHub上无法被百度收录的问题]]></title>
    <url>%2F2017%2F08%2Fbaidu-collect-github%2F</url>
    <content type="text"><![CDATA[博客在搭建完成后进行了适当的SEO，然后我分别将站点提交了谷歌和百度进行收录，提交的是GitHub Pages的地址。然而，提交给谷歌后不久就被收录了，但是百度却迟迟没有收录。当时这个问题还一直找不到原因，直到我试图在百度站长平台检测自己网站Robots时，根据错误信息才发现百度爬虫无法抓取，因为GitHub禁掉了百度爬虫。现将解决的过程记录下来。 解决思路这个问题的解决办法网上有几种说法，大致分为三种： 放弃将博客部署在GitHub上。 利用CDN。 同时部署到GitHub和Coding。 在知道这个问题的原因之后，第一时间想到的是就是搞一个云服务器，将博客部署到云服务器上。但是，考虑到云服务器只部署博客有点亏，而暂时也没有其他的东西需要用到云服务器，所以就放弃了，还是打算部署在GitHub上。第二种利用CDN来代理GitHub Pages上的博客的方法并不能很好的解决这个问题，因为如果附近的节点没有缓存，爬虫仍然会去爬取GitHub Pages上的内容。所以综合考虑，最后采取了第三种办法，同时部署到GitHub和Coding上，通过域名解析，将国内的请求解析到Coding上。 操作过程部署到Coding首先去Coding上注册了个账号并配置一下SSH Key，然后创建了一个&lt;username&gt;.coding.me的仓库，接着在hexo的配置文件中添加该仓库的地址，如下所示。 12345678# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: - git@github.com:hezhii/hezhii.github.io.git - git@git.coding.net:hezhou/hezhou.coding.me.git branch: master 这样就能同时将博客内容推到GitHub和Coding上。在Coding上选择项目--&gt;代码--&gt;Pages 服务，然后选择相应的分支即可完成部署。这样，通过&lt;username&gt;.github.io和&lt;username&gt;.coding.me就都能访问到博客了。这里有一个问题需要注意，如果使用了Travis CI进行自动部署并且是SSH方式登陆的，需要在ssh_config文件中添加上Coding相关配置，ssh_config中的内容如下所示。 1234567891011Host github.comUser gitStrictHostKeyChecking noIdentityFile ~/.ssh/id_rsaIdentitiesOnly yesHost git.coding.netUser gitStrictHostKeyChecking noIdentityFile ~/.ssh/id_rsaIdentitiesOnly yes 域名申请并解析完成了博客的部署后，就需要去弄个域名并添加解析。我是在万网申请的域名，申请完成后添加4条CNAME记录，将国内和国外的请求分别解析到Coding和GitHub，如下所示。 域名在申请后需要进行实名认证，否则将会停止解析，实名认证十分简单，上传个身份证正面照就可以了。审核所需时间说是3~5个工作日，但是我提交审核后过了6个工作日才完成。 域名绑定域名解析成功后，并不能通过域名访问博客，需要分别在GitHub和Coding上绑定自己申请的域名。其中，在博客的source目录下新建一个CNAME文件，文件写上自己申请的域名（不需要http://，www可有可无）并提交，即可完成GitHub上的绑定；而Coding上的绑定则更加简单，在Pages服务页面，通过自定义域名更能进行绑定即可。绑定完成后，待域名的解析生效即可通过申请的域名访问到博客了。我通过开关VPN分别访问进行了测试，确实国内会被解析到Coding，国外会被解析到GitHub。 其他问题 这样做之后，如果需要给其他的项目添加GitHub Pages服务，在国内就无法访问，我目前采取的方案是仍然同时部署到GitHub和Coding。 在百度站长上进行网站验证时，通过HTML方式验证会返回一个302的错误，怀疑是因为Coding有一个跳转页导致，目前没想好解决办法，采用CNAME的方式进行验证。 在百度站长上提交sitemap时，出现了一个主域校验失败的错误，检测sitemap.xml文件后，发现上面的地址仍是GitHub Pages的地址，需要将hexo配置文件中的url设置为申请的域名。]]></content>
      <categories>
        <category>航海日志</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
        <tag>BaiduSpider</tag>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5 Notification]]></title>
    <url>%2F2017%2F08%2Fnotification%2F</url>
    <content type="text"><![CDATA[The Notifications API allows web pages to control the display of system notifications to the end user. These are outside the top-level browsing context viewport, so therefore can be displayed even when the user has switched tabs or moved to a different app. The API is designed to be compatible with existing notification systems, across different platforms. 引子今天打开优酷网站发现弹出了一个是否允许显示通知的对话框，如下图所示。 当我选择允许后，过一会儿从电脑的右侧弹出了一个提示框，如下图所示。 当时觉得很有意思，便上网查询了一下相关的资料，了解到是HTML5的新API——Notification。于是，本着学习的想法，弄了一个小的demo。 Notification简介Notification API是HTML5中一个新的API，用于向用户配置和显示桌面通知，并且这一特性在Web Worker中可用。 构造方法通过let notification = new Notification(title, options);可以初始化一个Notification实例。构造函数中包含两个参数，其中title是通知的标题，而options则是一些初始参数，具体的参数列表如下： dir : 文字的方向；它的值可以是 auto（自动）, ltr（从左到右）, or rtl（从右到左） lang: 指定通知中所使用的语言。这个字符串必须在 BCP 47 language tag 文档中是有效的。 body: 通知中额外显示的字符串 tag: 赋予通知一个ID，以便在必要的时候对通知进行刷新、替换或移除。 icon: 一个图片的URL，将被用于显示通知的图标。 属性Notification主要包含一个静态属性和若干个实例属性，实例属性全部都是只读的属性，并且就是初始化该实例时option中的内容。具体的属性如下所示。 Notification.permission：这是一个静态的只读属性，用于表明当前通知显示授权状态的字符串。可能的值包括：denied (用户拒绝了通知的显示), granted (用户允许了通知的显示), or default (因为不知道用户的选择，所以浏览器的行为与 denied 时相同)。 title：通知的标题，Readonly。 dir：通知的文本显示方向，Readonly。 lang：通知使用的语言，Readonly。 body：通知中的文本内容，Readonly。 tag：通知的ID，Readonly。 icon：通知中图片的url地址，Readonly。 主要方法 Notification.requestPermission：这是一个静态方法，作用就是请求用户当前来源的权限以显示通知，效果就是上文中打开优酷网页时弹出的一个对话框。 close：关闭通知。 onclick：处理click事件的处理。每当用户点击通知时被触发。 onshow：处理show事件的处理。当通知显示的时候被触发。 onerror：处理error事件的处理。每当通知遇到错误时被触发。 onclose：处理 close 事件的处理。当用户关闭通知时被触发。 实例演示在熟悉了API之后，就尝试自己弄个实例来演示一下。 See the Pen Notification by Sylvanass (@Sylvanass) on CodePen. 点击DING!按钮，如果你是第一次，会出现下面的提示： 选择允许后，一会就会收到通知了，如下图所示。 此时，刷新或者关闭浏览器，通知仍然会显示。点击通知，可以产生一些交互效果。至此，关于HTML5 Notification的介绍和简单使用就完结了。]]></content>
      <categories>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Polymer 2.0]]></title>
    <url>%2F2017%2F08%2Flearn-polymer%2F</url>
    <content type="text"><![CDATA[Unlock the Power of Web Components. Polymer is a JavaScript library that helps you create custom reusable HTML elements, and use them to build performant, maintainable apps. 这篇博客是我在学习Polymer 2.0的过程中记录的一些笔记，并不是一个Polymer的教程。博客记录了我在学习Polymer时认为重要的一些地方以及一些自己的理解，便于以后回过头来复习和总结。 Polymer元素 使用&lt;dom-module&gt;标签来定义组件的样式和文档内容，给&lt;dom-module&gt;赋予一个匹配组件的is属性的id标记，并在&lt;dom-module&gt;中添加一个插入一个&lt;template&gt;标签，Polymer就会自动克隆模板内容到组件的local DOM中。1234567891011121314151617&lt;dom-module id="x-foo"&gt; &lt;template&gt; &lt;style&gt;&lt;/style&gt; &lt;div&gt;I am x-foo!&lt;/div&gt; &lt;!--类似于vue中的slot--&gt; &lt;content&gt;&lt;/content&gt; &lt;/template&gt;&lt;/dom-module&gt;&lt;script&gt; Polymer(&#123; is: 'x-foo' &#125;);&lt;/script&gt; 自定义元素名称必须是小写字母，且至少包含一个-。 Polymer现在只支持扩展原生HTML组件（例如input或button，将来会支持扩展其它自定义组件），这些原生组件扩展被称为自定义类型扩展组件。 为了在组件之间共享样式，可以在一个&lt;dom-module&gt;组件内打包一个样式集合。12345678910111213141516171819202122232425&lt;dom-module id="shared-styles"&gt; &lt;template&gt; &lt;style&gt; .red &#123; color: red; &#125; &lt;/style&gt; &lt;/template&gt;&lt;/dom-module&gt;&lt;!--如何使用--&gt;&lt;link rel="import" href="../shared-styles/shared-styles.html"&gt;&lt;dom-module id="x-foo"&gt; &lt;template&gt; &lt;!-- include the style module by name --&gt; &lt;style include="shared-styles"&gt;&lt;/style&gt; &lt;style&gt; :host &#123; display: block; &#125; &lt;/style&gt; &lt;div&gt;I am x-foo!&lt;/div&gt; &lt;/template&gt;&lt;/dom-module&gt;&lt;script&gt; Polymer(&#123;is: 'x-foo'&#125;);&lt;/script&gt; 组件属性 type：属性类型。支持Boolean、Date、Number、String、Array、Object，通过覆盖_deserializeValue方法可以增加对其他属性的支持。 value：属性的默认值。Boolean、Number、String、Function。如果默认值是数组或者实例对象，通过函数返回。 computed：计算属性。 notify：Boolean，当属性改变时，是否触发事件。触发propertyName-change readOnly：私有属性，通过方法调用。 reflectToAttribute：当组件的属性发生变化时，更新dom上的相应属性。 在template中使用属性时，驼峰命名需要使用-的方式，如果是元素原生的属性，后面加上$符号。 行为 Polymer支持使用称为behaviors的共享代码模块来扩展自定义组件原型。行为是一个看起来像一个典型的Polymer原型的对象；行为可以定义生命周期回调、声明的属性、默认标记、观察器和监听器；行为是从组件中提取出来的公共方法，类似于切面编程。12345Polymer(&#123; is: 'super-element', behaviors: [SuperBehavior]&#125;); 事件 listeners对象中定义了事件及其相应的处理方法。事件监听器可以监听this.$集合中的任意元素上的事件，事件类型需要定义为elementId.eventName的方式，这也就意味着，这种方式只能为拥有id的节点添加事件监听。12345678910111213141516171819202122232425&lt;dom-module id="x-custom”&gt; &lt;template&gt; &lt;div&gt;I will respond&lt;/div&gt; &lt;div&gt;to a tap on&lt;/div&gt; &lt;div&gt;any of my children!&lt;/div&gt; &lt;div id="special"&gt;I am special!&lt;/div&gt; &lt;/template&gt; &lt;/dom-module&gt;&lt;script&gt; Polymer(&#123; is: 'x-custom’, listeners: &#123; 'tap': 'regularTap’, 'special.tap': ‘specialTap' &#125;, regularTap: function(e) &#123; alert("Thank you for tapping"); &#125;, specialTap: function(e) &#123; alert("It was special tapping"); &#125; &#125;); &lt;/script&gt; 基于上面个的方法，如果不想仅仅为了添加事件而指定元素id，可以通过on-event的方法指定事件。 通过下面的方法可以绑定或解绑事件。123this.listen(this.$.myButton, 'tap', 'onTap');this.unlisten(this.$.myButton, 'tap', 'onTap'); fire方法可以出发一个自定义事件。 数据系统 notify属性控制属性的修改是否会向上流动，默认值为false，即该属性修改后，不会触发任何东西。不会影响到其他的，阻止数据出去。 readOnly属性控制属性是否可以向下流动，默认值为false，即相应数据的修改不会影响到自己，阻止数据进来。 [[]]阻止数据向上流动，即使指定notify为true。 注意：这里的向上、向下流动，不是data和界面之间的流动，而是父组件和子组件。notify和readOnly是对自己的属性而言的，而[[ ]]和{{ }}相当于是在使用该属性的时候，对使用的那个属性而言。 全局配置 dom: shady，所有的Local DOM都使用shady DOM进行渲染，即使只是shadow DOM(当前默认使用此选项). shadow，Local DOM在支持shadow DOM时使用shadow DOM做渲染(未来会默认使用此选项)。 lazyRegister: true，将一些注册时的活动延迟到第一个组件实例被创建时，默认是false(默认值将来可能改变)。 max，延迟所有行为执行一直到第一个组件被创建。当设置lazyRegister为max时，不能改变一个组件的is属性或通过定义factoryImpl方法来创建一个自定义构造函数。Polymer会调用组件的beforeRegister用以保留使用ES6定义组件的能力。组件的beforeRegister会在特性的beforeRegister之前调用. useNativeCSSProperties：为true时, Polymer在浏览器支持时使用本地自定义CSS属性。默认是false，由于Safari 9还不支持。 noUrlSettings：为true时, Polymer的设置只能通过页面上脚本来设置，也就是说通过URL查询字符串设置的?dom=shadow会被忽略，默认为false。 API Polymer.CaseMap：提供两个静态方法，用来完成-和驼峰命名之间的互转。polymer-element &lt;==&gt; polymerElement 特性 支持父子组件双向的数据流，对数据的流动有完全的控制权。 组件间的样式共享，利用CSS变量，进行组件的样式定制。 修改了对象的getter、setter，当对象的属性发生变化的时候，调用set方法设置属性并调用监听该属性变化的方法。 behavior的作用和vue中的mixin类似，提供一些通用的处理。]]></content>
      <categories>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Polymer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客搭建过程]]></title>
    <url>%2F2017%2F08%2Fbuild-blog%2F</url>
    <content type="text"><![CDATA[博客基于GitHub Pages和Hexo搭建，使用Travis CI自动部署，具体如何操作网上有全面的教程，我这里也就没有必要一一讲述了，也不是很复杂的一个东西。这篇博客，也权当作是我自己的一个笔记，记录下我自己的搭建过程以及我稍微花了点时间去处理的一些问题。 环境准备 Git Node.js Ruby 我自己电脑上本来也就有这些环境，所以这一步骤就直接跳过了。各种环境如何安装，网上一查也就知道了。 安装Hexo安装以及使用Hexo是直接参考Hexo官网上的文档完成的。官网上的文档还是比较全面的，基本读一遍就能耍起来了。不过在安装的过程中却是在这个地方遇到一点问题，当时直接就npm install hexo-cli -g进行安装，在执行的过程中却卡住了相当长的一段时间，并且也没有任何的错误提示。起初我还以为是需要翻墙，等了一会以后就直接结束安装，然后打开vpn重新安装，然而结果还是一样。但是，这一次我没有退出，而是先去干了点别的事情，过了一会再来看的时候，给了个没有权限的错误提示，然后加上sudo就安装成功了。 初始化及配置这一步参考官网上的文档进行操作即可，基本就是hexo init &lt;folder&gt;初始化一个项目，接着进入到该目录npm install安装依赖，然后修改下配置文件的过程。有一点需要注意的是，就算没有自己的一个站点，也不要删除配置文件中的url参数。 基本使用配置完成后，执行hexo server即可在本地启动一个服务，通过浏览器访问http://localhost:4000/就可以看到博客页面。在使用时通常执行hexo n &lt;name&gt;初始化一篇博文，然后对博文的内容进行编辑，如果启动了本地服务，刷新页面可以看到博客内容的修改。博文完成后，通过hexo deploy即可部署到配置文件中的指定站点，在部署到GitHub上时，需要安装hexo-deployer-git插件。 GitHub Pages在GitHub上新建一个yourname.github.io的仓库，仓库master分支中的静态文件即可通过https://yourname.github.io直接进行访问。如果希望其他仓库中的内容也能通过GitHub Pages进行访问，那么就在该仓库中创建一个gh-pages的分支，该分支下的内容可以通过yourname.github.io/repoitoryName进行访问。为了方便管理，我将博客部署到了hezhii.github.io中的master分支上，博客的一些源文件则提交到了该仓库的hexo分支上，利用Travis CI自动将hexo分支中的更新部署到master分支上。 Travis CITravis CI结合hexo具体如何使用，网上也有相当多的教程，主要涉及到Travis CI命令行工具的安装和使用、访问GitHub的一个配置以及Travis CI的配置。其中命令行工具的安装和使用十分简单，找个教程照着做就可以了。关于GitHub访问的一个配置，我使用的是SSH的方式，还可以使用GitHub Access Token，这里需要注意的是不要忘记hexo配置文件中GitHub的仓库地址也应该使用SSH。Travis CI中的配置可以参考我的配置，其中如果没有设置时区的话，GitHub上的提交时间就不是北京时间。 主题主题我使用的是相当火的NexT主题，主题的安装和使用在官方文档上也有详细的说明，我在使用的过程中参考了这篇博文中的一些配置。]]></content>
      <categories>
        <category>航海日志</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
        <tag>Travis CI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从此，每天不一样]]></title>
    <url>%2F2017%2F08%2Fmy-first-blog%2F</url>
    <content type="text"><![CDATA[韶光易逝二十多年时光转眼即逝，过去的一切历历在目，哭过、笑过、疯过、闹过……过去的一切还是让它过去吧，人不能总是活在过去。但是，却是应该吸取过去的经验，努力让自己变得不同。 珍惜现在现在的一切也许不是自己想要的，但一定是自找的。 庆幸现在是来上海的第四个月，很多事情其实跟我当初做出这个计划时期望的不太一样。但是，我也很庆幸自己做出了这个决定。否则，我现在应该不会写下这篇博客了，各有各的好罢了。这段时间的一些经历，让自己作出了许多的改变，我想这会是影响我接下来的人生的一段经历。 为什么要写博客有时候会想，毕业一年了才想到要弄一个自己的博客会不会太晚。但是，做一件自己想做的是事情，应该任何时候都不会晚吧。其实以前也会写一些东西、总结一些东西，发发说说或者朋友圈，但是现在渐渐的少了，很少分享自己的生活，总是在自己玩着。突然觉得，还是应该要在这个世上留下点什么，证明自己来过。所以，就弄一个自己的博客，分享一些自己总结的东西，如果能给任何一个人带来任何的帮助，那做的这一切也就是值得了的。 博客内容虽然自己是一个程序员，但并不打算弄一个纯技术博客，除了一些学习、工作上的内容，也打算多的分享生活。也许我某些失败的经历可以成为大家的前车之鉴，使大家能少踩点坑。 接下来做什么注意身体 烟是一定要戒的，听说任何时候戒都来得及呢。戒烟有什么难，已经戒了半年了。 坚持锻炼。下了个keep，每天就得要坚持打卡，羽毛球爱好也不能丢。 少熬夜。上年纪了，身体也不行了，游戏什么的也玩不动了。 学无止境 人丑多读书。读书的习惯要坚持下去，读别人的人生，悟自己的道。 代码还是要继续撸的，别忘了自己是干什么的。 博客也要坚持更新呢，衷于原创。 要改改了 性格怕还是有点缺陷 有话好好说 总结别说这种丧气话，还有机会的。]]></content>
      <categories>
        <category>心灵鸡汤</category>
      </categories>
  </entry>
</search>
